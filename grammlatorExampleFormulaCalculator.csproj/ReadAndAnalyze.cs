using GrammlatorRuntime;
using System;
using System.Collections.Generic;
using System.Diagnostics;
// Simplify access to the enumeration values the input accessor Symbol may assume
using ClassifierResult = GrammlatorExampleFormulaCalculator.InputClassifier.ClassifierResult;
using LexerResult = GrammlatorExampleFormulaCalculator.MyLexerClass.LexerResult;

namespace GrammlatorRuntime
{
    using System.Runtime.InteropServices; // to overlay fields of the elements of the attribute array

    // The example uses attributes with the C# types the types double and char.
    // Thes types are added to the declaration of the elements of the attribute stack.
    public partial struct MultiTypeStruct
    {
        [FieldOffset(0)] // [FieldOffset(0)] is used for object types
        public string _string; // atributes of type string are used for identifier

        [FieldOffset(8)] // [FieldOffset(8)] is used for value types 
        public double _double; // attributes of type double are used here and in MaySymbolInput

        [FieldOffset(8)] // [FieldOffset(8)] is used for value types 
        public char _char; // attributes of type char are used in MySymbolInput and MyCharacterInput

        [FieldOffset(8)] // [FieldOffset(8)] is used for value types 
        public int _int; // attributes of type int are used in MySymbolInput
    }
}

namespace GrammlatorExampleFormulaCalculator
{
    // In the following attributed grammar, "double" is used as type of attributes.
    // There are no predefined types in the attribute stack of the aGaC-sources.
    // All types used are declared in the following manner:

    public class ReadAndAnalyzeClass : GrammlatorApplication
    {
        private readonly InputClassifier MyInputClassifier;
        private readonly MyLexerClass MyLexer;

        /// <summary>
        /// Constructor
        /// </summary>
        public ReadAndAnalyzeClass()
        {
            MyInputClassifier = new InputClassifier(_a);
            MyLexer = new MyLexerClass(_a, _s, MyInputClassifier, LexicalErrorHandler);
        }

        // A dictionary will be used to store identifiers and their values
        private readonly Dictionary<string, double> MyDictionary = new Dictionary<string, double>();

        public void ReadAndAnalyze()
        {
            Console.WriteLine("This calculator evaluates single line numeric expressions with floating numbers,");
            Console.WriteLine("unary operators + and - , arithmetic operators + and - (lower priority), * and / (higher priority).");
            Console.WriteLine("You may use parentheses. You may define and use variables. Undefined variables have the value NaN.");
            Console.WriteLine("Examples");
            Console.WriteLine("12+99/3/-3");
            Console.WriteLine("(12+99)/(3/-3)");
            Console.WriteLine("Pi=355/113");
            Console.WriteLine("3*Pi+5");
            // This is a manually programmed input loop with calls to ComputeExpression
            while (true)
            {
                Console.WriteLine("Input a numeric expression or an empty line to stop the program:");

                // Look ahead one input symbol to check for empty line
                MyInputClassifier.FetchSymbol();
                if (MyInputClassifier.Symbol == ClassifierResult.Eol)
                {
                    break;
                }

                ComputeExpression(); // <------------ execute the code generated by grammlator

                // ComputeExpression will call the error handler, if it can not recognize a legal expression,
                // for example if you enter a letter (interpreted by myCharInput als "unknown"-Symbol)
                // The following grammar does not use an end symbol which stops the analyzing process.
                // Therefore ComputeExpression() returns as soon as a look ahead input symbol can not be accepted. 

                string RemainingCharacters = MyLexer.GetRemainingCharactersOfLine();
                if (!string.IsNullOrEmpty(RemainingCharacters))
                {
                    Console.WriteLine("Remaining characters ignored: '" + RemainingCharacters + "'");
                }
            }
            Console.WriteLine("Good bye!");
        }

        /// <summary>
        /// The ErrorHandler is called by the generated code, if a input symbol is not legal.
        /// i is the number of the analyzers state the error occured in.
        /// </summary>
        /// <param name="i"></param>
        private void ErrorHandler(int i, string stateDescription)
        {
            // the symbol that caused the error is available in MySymbolInput.Symbol.
            // because it caused an error, it can not be accepted
            Debug.Assert(!MyLexer.Accepted);
            Console.WriteLine(
                $"Error: illegal symbol \"{MyLexer.Symbol.ToString()}\" in parser state {i.ToString()}:");
            Console.WriteLine(stateDescription);
            // return to generated code, which will set the stacks to correct states and then return
        }

        private void LexicalErrorHandler(int i, string illegalInput, string stateDescription)
        {
            Console.WriteLine("Lexical error: the \"" + illegalInput + "\" is not allowed in the following lexical analyzer state:");
            Console.WriteLine(stateDescription);
            Console.WriteLine("The lexical analyzer will interpret this as \"Unknown\"");
        }

        #region grammar
        //| /* Lines starting with //| contain grammar rules, which are evaluated by grammlator.
        //|    This is the first line of ReadAndAnalyze interpreted by the grammlator System.
        //|    It is interpreted as comment.
        //|    The grammar may contain comments alike comments of C# */
        //|
        //| /* The first grammlator instruction is the definition of prefixes used in the generated code 
        //|    (for example " if (MySymbolInput.Symbol == SymbolEnum.number)"
        //|    and of the terminal symbols of the grammar with their respectiv semantic attributes */
        //|
        //| MyLexer, LexerResult = 
        //|    AddOp | SubOp | MultOp | DivOp
        //|    | RightParentheses | Eol | EqualChar
        //|    | Unknown | LTChar | GTChar // these input symbols are not used 
        //|    | LeftParentheses 
        //|    | Number(double value) | Identifier (string identifier)
        //|    ;

        public enum Copy2OfMySymbolInput_SymbolEnum
        {
#pragma warning disable RCS1057 // Add empty line between declarations.
            AddOp, SubOp, MultOp, DivOp,
            RightParentheses, Eol, EqualChar,
            Unknown, LTChar, GTChar,
            LeftParentheses,
            Number, Identifier
#pragma warning restore RCS1057 // Add empty line between declarations.
        }

        // This enum declaration is optional and redundant. 
        // If it is given, grammlator compares the names and positions of the elements
        // with the names and positions of the terminal symbols.

        //| // The following first grammar rule *= ... ; defines the startsymbol
        //| *= MyGrammar, Eol;  

        //|  // Define aliases for terminal symbols to improve readability
        //|  '+' = AddOp; '-' = SubOp; '*' = MultOp; '/' = DivOp;
        //|  ')' = RightParentheses; '=' = EqualChar; '(' = LeftParentheses;

        //| /* When you remove ", Eol", grammlator will find more conflicts, because
        //|  * then  "1" will be a valid input but also "1+2" and it is not defined
        //|  * in the second case whether the parser should stop after "1" or accept "+".
        //|  * In this case the given constant priorities will save those conflict.
        //|  */
        //|
        //| //  The next line defines the nonterminal symbol MyGrammar.

        //| MyGrammar = 
        //|    Expression(double result) ?-10?  
        private static void WriteResult(double result)
        { // grammlator analyzes this declaration and assigns it as semantic action to this alternative
            Console.WriteLine("Result = " + result);
        }

        //|    | Identifier(string identifier), Priority05, '=', Expression(double result) ?-2?
        private void AssignValueToIdentifier(string identifier, double result)
        {
            if (MyDictionary.ContainsKey(identifier))
            {
                MyDictionary[identifier] = result;
                Console.WriteLine("Reassignment " + identifier + " = " + result);
            }
            else
            {
                MyDictionary.Add(identifier, result);
                Console.WriteLine("Assignment " + identifier + " = " + result);
            }
        }
        //|
        //| PrimaryExpression(double value)=
        //|      '(', Expression(double value), ')'
        //|    | Number(double value)?-91?
        //|    | Identifier(string identifier)?-92?
        private void IdentifierInExpression(out double value, string identifier)
        {
            if (!MyDictionary.TryGetValue(identifier, out value))
                value = double.NaN;
        }
        //|
        //| Expression(double value)= 
        //|      PrimaryExpression(double value)
        //|    | Priority50, '+', PrimaryExpression(double value)?51?
        //|    | Priority50, '-', PrimaryExpression(double value) ?51?
        private static void Negate(ref double value) { value = -value; }
        //|    | Expression(double multiplicand), Priority20, '*',  Expression(double multiplier)?21?
        private static void Multiply(out double value, double multiplicand, double multiplier)
        {
            value = multiplicand * multiplier;
        }

        //|    | Expression(double dividend), Priority20, '/', Expression(double divisor)?21?
        private static void Divide(out double value, double dividend, double divisor)
        {
            value = dividend / divisor;
        }

        //| // Priorities -40 and -41 solve the conflict, when the next symbol is multOp or divOp
        //|    | Expression(double leftAddend), Priority10, '+',  Expression(double rightAddend) ?11?
        private static void Add(out double value, double leftAddend, double rightAddend)
        {
            value = leftAddend + rightAddend;
        }

        //|    | Expression(double minuend), Priority10, '-', Expression(double subtrahend)?11?
        private static void Sub(out double value, double minuend, double subtrahend)
        {
            value = minuend - subtrahend;
        }

        //| Priority05= ?05?
        //| Priority10= ?10?
        //| Priority20= ?20?
        //| Priority50= ?50?

        #endregion grammar

        // The following few lines up to #region and the lines after #endregion are programmed manually

        /// <summary>
        /// ComputeExpression implements the analyzer
        /// </summary>
        private void ComputeExpression()
        {
            /*
             * The content of the region "grammlator generated" is (replaced and) inserted by grammlator
             */
            #region grammlator generated 25.05.2019 by Grammlator version 0:21 (build 25.05.2019 12:43:56 +00:00)
            Int32 StateStackInitialCount = _s.Count;
            Int32 AttributeStackInitialCount = _a.Count;
            String StateDescription;
            // State 1 (0)
            StateDescription =
                 "*Startsymbol= ►MyGrammar, Eol;";
            _s.Push(0);
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s2;
            if (MyLexer.Symbol == LexerResult.LeftParentheses)
                goto as21;
            if (MyLexer.Symbol == LexerResult.Number)
            {
                MyLexer.AcceptSymbol();
                goto s5;
            }
            if (MyLexer.Symbol != LexerResult.Identifier)
            {
                ErrorHandler(1, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
            MyLexer.AcceptSymbol();
            // State 17
            StateDescription =
                 "MyGrammar= Identifier(string identifier), ►Priority05, '=', Expression(double result);\r\n"
               + "PrimaryExpression(double value)= Identifier(string identifier)●;";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol == LexerResult.EqualChar)
            {
                // State 18
                StateDescription =
                     "MyGrammar= Identifier(string identifier), Priority05, ►'=', Expression(double result);";
                MyLexer.FetchSymbol();
                if (MyLexer.Symbol != LexerResult.EqualChar)
                {
                    ErrorHandler(18, StateDescription);
                    goto x1;
                }
                Debug.Assert(MyLexer.Symbol == LexerResult.EqualChar);
                MyLexer.AcceptSymbol();
                // State 19 (7)
                StateDescription =
                     "MyGrammar= Identifier(string identifier), Priority05, '=', ►Expression(double result);";
                _s.Push(7);
                MyLexer.FetchSymbol();
                if (MyLexer.Symbol <= LexerResult.SubOp)
                    goto s2;
                if (MyLexer.Symbol == LexerResult.LeftParentheses)
                    goto as21;
                if (MyLexer.Symbol == LexerResult.Number)
                {
                    MyLexer.AcceptSymbol();
                    goto s20;
                }
                if (MyLexer.Symbol != LexerResult.Identifier)
                {
                    ErrorHandler(19, StateDescription);
                    goto x1;
                }
                Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
                MyLexer.AcceptSymbol();
                /* Reduction 16
                 * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
                 */

                IdentifierInExpression(
                   value: out _a.PeekRef(0)._double,
                   identifier: _a.PeekClear(0)._string
                   );

                goto s20;
            }
            if (MyLexer.Symbol == LexerResult.RightParentheses
               || MyLexer.Symbol >= LexerResult.Unknown)
            {
                ErrorHandler(17, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol <= LexerResult.DivOp
               || MyLexer.Symbol == LexerResult.Eol);
            /* Reduction 15
             * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
             */

            IdentifierInExpression(
               value: out _a.PeekRef(0)._double,
               identifier: _a.PeekClear(0)._string
               );

        s5:
            // State 5
            StateDescription =
                 "MyGrammar= Expression(double result)●;\r\n"
               + "Expression(double value)= Expression(double multiplicand), ►Priority20, '*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), ►Priority20, '/', Expression(double divisor);\r\n"
               + "Expression(double value)= Expression(double leftAddend), ►Priority10, '+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double minuend), ►Priority10, '-', Expression(double subtrahend);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol == LexerResult.Eol)
            {
                /* Reduction 5, aStack: -1
                 * MyGrammar= Expression(double result);◄ Priority: -10, method: WriteResult, aStack: -1
                 */

                WriteResult(
                   result: _a.PeekRef(0)._double
                   );

                _a.Free();
                goto s16;
            }
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s6;
            if (MyLexer.Symbol >= LexerResult.RightParentheses)
            {
                ErrorHandler(5, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.MultOp || MyLexer.Symbol == LexerResult.DivOp);
        s11:
            // State 11
            StateDescription =
                 "Expression(double value)= Expression(double multiplicand), Priority20, ►'*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), Priority20, ►'/', Expression(double divisor);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol == LexerResult.MultOp)
            {
                MyLexer.AcceptSymbol();
                // State 14 (6)
                StateDescription =
                     "Expression(double value)= Expression(double multiplicand), Priority20, '*', ►Expression(double multiplier);";
                _s.Push(6);
                MyLexer.FetchSymbol();
                if (MyLexer.Symbol <= LexerResult.SubOp)
                    goto s2;
                if (MyLexer.Symbol == LexerResult.LeftParentheses)
                    goto as21;
                if (MyLexer.Symbol == LexerResult.Number)
                {
                    MyLexer.AcceptSymbol();
                    goto r13;
                }
                if (MyLexer.Symbol != LexerResult.Identifier)
                {
                    ErrorHandler(14, StateDescription);
                    goto x1;
                }
                Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
                MyLexer.AcceptSymbol();
                /* Reduction 12
                 * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
                 */

                IdentifierInExpression(
                   value: out _a.PeekRef(0)._double,
                   identifier: _a.PeekClear(0)._string
                   );

                goto r13;
            }
            if (MyLexer.Symbol != LexerResult.DivOp)
            {
                ErrorHandler(11, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.DivOp);
            MyLexer.AcceptSymbol();
            // State 12 (5)
            StateDescription =
                 "Expression(double value)= Expression(double dividend), Priority20, '/', ►Expression(double divisor);";
            _s.Push(5);
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s2;
            if (MyLexer.Symbol == LexerResult.LeftParentheses)
                goto as21;
            if (MyLexer.Symbol == LexerResult.Number)
            {
                MyLexer.AcceptSymbol();
                goto r11;
            }
            if (MyLexer.Symbol != LexerResult.Identifier)
            {
                ErrorHandler(12, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
            MyLexer.AcceptSymbol();
            /* Reduction 10
             * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
             */

            IdentifierInExpression(
               value: out _a.PeekRef(0)._double,
               identifier: _a.PeekClear(0)._string
               );

        r11:
            /* Reduction 11, sStack: -1, aStack: -1
             * Expression(double value)= Expression(double dividend), Priority20, '/', Expression(double divisor);◄ Priority: 21, method: Divide, aStack: -1
             */
            _s.Pop();

            Divide(
               value: out _a.PeekRef(-1)._double,
               dividend: _a.PeekRef(-1)._double,
               divisor: _a.PeekRef(0)._double
               );

            _a.Free();
        b1:
            /* Branch 1*/
            switch (_s.Peek())
            {
                case 0:
                    goto s5;
                case 4:
                    goto s10;
                case 5:
                    goto r11;
                case 6:
                    goto r13;
                case 7:
                    goto s20;
                case 8:
                    goto s22;
                    /*case 3:
                    default: break;
                    */
            }
        s8:
            // State 8
            StateDescription =
                 "Expression(double value)= Expression(double multiplicand), ►Priority20, '*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), ►Priority20, '/', Expression(double divisor);\r\n"
               + "Expression(double value)= Expression(double leftAddend), ►Priority10, '+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double minuend), ►Priority10, '-', Expression(double subtrahend);\r\n"
               + "Expression(double value)= Expression(double minuend), Priority10, '-', Expression(double subtrahend)●;";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol >= LexerResult.EqualChar)
            {
                ErrorHandler(8, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol == LexerResult.MultOp || MyLexer.Symbol == LexerResult.DivOp)
                goto s11;
            Debug.Assert(MyLexer.Symbol <= LexerResult.SubOp
               || MyLexer.Symbol == LexerResult.RightParentheses || MyLexer.Symbol == LexerResult.Eol);
            /* Reduction 7, sStack: -1, aStack: -1
             * Expression(double value)= Expression(double minuend), Priority10, '-', Expression(double subtrahend);◄ Priority: 11, method: Sub, aStack: -1
             */
            _s.Pop();

            Sub(
               value: out _a.PeekRef(-1)._double,
               minuend: _a.PeekRef(-1)._double,
               subtrahend: _a.PeekRef(0)._double
               );

            _a.Free();
            goto b1;

        s2:
            // State 2
            StateDescription =
                 "Expression(double value)= Priority50, ►'+', PrimaryExpression(double value);\r\n"
               + "Expression(double value)= Priority50, ►'-', PrimaryExpression(double value);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol >= LexerResult.MultOp)
            {
                ErrorHandler(2, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol == LexerResult.SubOp)
            {
                MyLexer.AcceptSymbol();
                // State 3 (1)
                StateDescription =
                     "Expression(double value)= Priority50, '-', ►PrimaryExpression(double value);";
                _s.Push(1);
                MyLexer.FetchSymbol();
                if (MyLexer.Symbol <= LexerResult.GTChar)
                {
                    ErrorHandler(3, StateDescription);
                    goto x1;
                }
                if (MyLexer.Symbol == LexerResult.LeftParentheses)
                    goto as21;
                if (MyLexer.Symbol == LexerResult.Number)
                {
                    MyLexer.AcceptSymbol();
                    goto r2;
                }
                Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
                MyLexer.AcceptSymbol();
                /* Reduction 1
                 * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
                 */

                IdentifierInExpression(
                   value: out _a.PeekRef(0)._double,
                   identifier: _a.PeekClear(0)._string
                   );

                goto r2;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.AddOp);
            MyLexer.AcceptSymbol();
            // State 4 (2)
            StateDescription =
                 "Expression(double value)= Priority50, '+', ►PrimaryExpression(double value);";
            _s.Push(2);
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol <= LexerResult.GTChar)
            {
                ErrorHandler(4, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol == LexerResult.LeftParentheses)
                goto as21;
            if (MyLexer.Symbol == LexerResult.Number)
            {
                MyLexer.AcceptSymbol();
                goto r4;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
            MyLexer.AcceptSymbol();
            /* Reduction 3, sStack: -1
             * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
             * then: Expression(double value)= Priority50, '+', PrimaryExpression(double value);◄ Priority: 51
             */
            _s.Pop();

            IdentifierInExpression(
               value: out _a.PeekRef(0)._double,
               identifier: _a.PeekClear(0)._string
               );

            goto b1;

        s6:
            // State 6
            StateDescription =
                 "Expression(double value)= Expression(double leftAddend), Priority10, ►'+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double minuend), Priority10, ►'-', Expression(double subtrahend);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol >= LexerResult.MultOp)
            {
                ErrorHandler(6, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol == LexerResult.SubOp)
            {
                MyLexer.AcceptSymbol();
                // State 7 (3)
                StateDescription =
                     "Expression(double value)= Expression(double minuend), Priority10, '-', ►Expression(double subtrahend);";
                _s.Push(3);
                MyLexer.FetchSymbol();
                if (MyLexer.Symbol <= LexerResult.SubOp)
                    goto s2;
                if (MyLexer.Symbol == LexerResult.LeftParentheses)
                    goto as21;
                if (MyLexer.Symbol == LexerResult.Number)
                {
                    MyLexer.AcceptSymbol();
                    goto s8;
                }
                if (MyLexer.Symbol != LexerResult.Identifier)
                {
                    ErrorHandler(7, StateDescription);
                    goto x1;
                }
                Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
                MyLexer.AcceptSymbol();
                /* Reduction 6
                 * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
                 */

                IdentifierInExpression(
                   value: out _a.PeekRef(0)._double,
                   identifier: _a.PeekClear(0)._string
                   );

                goto s8;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.AddOp);
            MyLexer.AcceptSymbol();
            // State 9 (4)
            StateDescription =
                 "Expression(double value)= Expression(double leftAddend), Priority10, '+', ►Expression(double rightAddend);";
            _s.Push(4);
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s2;
            if (MyLexer.Symbol == LexerResult.LeftParentheses)
                goto as21;
            if (MyLexer.Symbol == LexerResult.Number)
            {
                MyLexer.AcceptSymbol();
                goto s10;
            }
            if (MyLexer.Symbol != LexerResult.Identifier)
            {
                ErrorHandler(9, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
            MyLexer.AcceptSymbol();
            /* Reduction 8
             * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
             */

            IdentifierInExpression(
               value: out _a.PeekRef(0)._double,
               identifier: _a.PeekClear(0)._string
               );

        s10:
            // State 10
            StateDescription =
                 "Expression(double value)= Expression(double multiplicand), ►Priority20, '*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), ►Priority20, '/', Expression(double divisor);\r\n"
               + "Expression(double value)= Expression(double leftAddend), ►Priority10, '+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double leftAddend), Priority10, '+', Expression(double rightAddend)●;\r\n"
               + "Expression(double value)= Expression(double minuend), ►Priority10, '-', Expression(double subtrahend);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol >= LexerResult.EqualChar)
            {
                ErrorHandler(10, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol == LexerResult.MultOp || MyLexer.Symbol == LexerResult.DivOp)
                goto s11;
            Debug.Assert(MyLexer.Symbol <= LexerResult.SubOp
               || MyLexer.Symbol == LexerResult.RightParentheses || MyLexer.Symbol == LexerResult.Eol);
            /* Reduction 9, sStack: -1, aStack: -1
             * Expression(double value)= Expression(double leftAddend), Priority10, '+', Expression(double rightAddend);◄ Priority: 11, method: Add, aStack: -1
             */
            _s.Pop();

            Add(
               value: out _a.PeekRef(-1)._double,
               leftAddend: _a.PeekRef(-1)._double,
               rightAddend: _a.PeekRef(0)._double
               );

            _a.Free();
            goto b1;

        s16:
            // State 16
            StateDescription =
                 "*Startsymbol= MyGrammar, ►Eol;";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol != LexerResult.Eol)
            {
                ErrorHandler(16, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Eol);
            MyLexer.AcceptSymbol();
            /* Reduction 14
             * *Startsymbol= MyGrammar, Eol;◄
             */
            // Halt: a definition of the startsymbol with 0 attributes has been recognized.
            _s.Pop();
            goto EndOfGeneratedCode;
        s20:
            // State 20
            StateDescription =
                 "MyGrammar= Identifier(string identifier), Priority05, '=', Expression(double result)●;\r\n"
               + "Expression(double value)= Expression(double multiplicand), ►Priority20, '*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), ►Priority20, '/', Expression(double divisor);\r\n"
               + "Expression(double value)= Expression(double leftAddend), ►Priority10, '+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double minuend), ►Priority10, '-', Expression(double subtrahend);";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol == LexerResult.Eol)
            {
                /* Reduction 17, sStack: -1, aStack: -2
                 * MyGrammar= Identifier(string identifier), Priority05, '=', Expression(double result);◄ Priority: -2, method: AssignValueToIdentifier, aStack: -2
                 */
                _s.Pop();

                AssignValueToIdentifier(
                   identifier: _a.PeekRef(-1)._string,
                   result: _a.PeekRef(0)._double
                   );

                _a.Free(2);
                goto s16;
            }
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s6;
            if (MyLexer.Symbol >= LexerResult.RightParentheses)
            {
                ErrorHandler(20, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.MultOp || MyLexer.Symbol == LexerResult.DivOp);
            goto s11;

        as21:
            MyLexer.AcceptSymbol();
            // State 21 (8)
            StateDescription =
                 "PrimaryExpression(double value)= '(', ►Expression(double value), ')';";
            _s.Push(8);
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s2;
            if (MyLexer.Symbol == LexerResult.LeftParentheses)
                goto as21;
            if (MyLexer.Symbol == LexerResult.Number)
            {
                MyLexer.AcceptSymbol();
                goto s22;
            }
            if (MyLexer.Symbol != LexerResult.Identifier)
            {
                ErrorHandler(21, StateDescription);
                goto x1;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.Identifier);
            MyLexer.AcceptSymbol();
            /* Reduction 18
             * PrimaryExpression(double value)= Identifier(string identifier);◄ Priority: -92, method: IdentifierInExpression
             */

            IdentifierInExpression(
               value: out _a.PeekRef(0)._double,
               identifier: _a.PeekClear(0)._string
               );

        s22:
            // State 22
            StateDescription =
                 "Expression(double value)= Expression(double multiplicand), ►Priority20, '*', Expression(double multiplier);\r\n"
               + "Expression(double value)= Expression(double dividend), ►Priority20, '/', Expression(double divisor);\r\n"
               + "Expression(double value)= Expression(double leftAddend), ►Priority10, '+', Expression(double rightAddend);\r\n"
               + "Expression(double value)= Expression(double minuend), ►Priority10, '-', Expression(double subtrahend);\r\n"
               + "PrimaryExpression(double value)= '(', Expression(double value), ►')';";
            MyLexer.FetchSymbol();
            if (MyLexer.Symbol >= LexerResult.Eol)
            {
                ErrorHandler(22, StateDescription);
                goto x1;
            }
            if (MyLexer.Symbol <= LexerResult.SubOp)
                goto s6;
            if (MyLexer.Symbol == LexerResult.RightParentheses)
            {
                MyLexer.AcceptSymbol();
                /* Reduction 19, sStack: -1
                 * PrimaryExpression(double value)= '(', Expression(double value), ')';◄
                 */
                _s.Pop();
                /* Branch 2*/
                switch (_s.Peek())
                {
                    case 1:
                        goto r2;
                    case 2:
                        goto r4;
                    case 3:
                        goto s8;
                    case 4:
                        goto s10;
                    case 5:
                        goto r11;
                    case 6:
                        goto r13;
                    case 7:
                        goto s20;
                    case 8:
                        goto s22;
                        /*case 0:
                        default: break;
                        */
                }
                goto s5;
            }
            Debug.Assert(MyLexer.Symbol == LexerResult.MultOp || MyLexer.Symbol == LexerResult.DivOp);
            goto s11;

        r2:
            /* Reduction 2, sStack: -1
             * Expression(double value)= Priority50, '-', PrimaryExpression(double value);◄ Priority: 51, method: Negate
             */
            _s.Pop();

            Negate(
               value: ref _a.PeekRef(0)._double
               );

            goto b1;

        r4:
            /* Reduction 4, sStack: -1
             * Expression(double value)= Priority50, '+', PrimaryExpression(double value);◄ Priority: 51
             */
            _s.Pop();
            goto b1;

        r13:
            /* Reduction 13, sStack: -1, aStack: -1
             * Expression(double value)= Expression(double multiplicand), Priority20, '*', Expression(double multiplier);◄ Priority: 21, method: Multiply, aStack: -1
             */
            _s.Pop();

            Multiply(
               value: out _a.PeekRef(-1)._double,
               multiplicand: _a.PeekRef(-1)._double,
               multiplier: _a.PeekRef(0)._double
               );

            _a.Free();
            goto b1;

        x1:
            // This point is reached after an input error has been handled and no exception has been thrown
            _s.Pop(_s.Count - StateStackInitialCount);
            _a.Free(_a.Count - AttributeStackInitialCount);

        EndOfGeneratedCode:
            ;
            #endregion grammlator generated 25.05.2019 by Grammlator version 0:21 (build 25.05.2019 12:43:56 +00:00)

        }
    }
}
