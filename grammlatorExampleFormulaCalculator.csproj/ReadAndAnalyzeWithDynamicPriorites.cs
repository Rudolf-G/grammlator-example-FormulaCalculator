using GrammlatorRuntime;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace GrammlatorExampleFormulaCalculator {
   class ReadAndAnalyzeWithDynamicPriorites : GrammlatorApplication {
      private const string HowtoUse =
@"This calculator evaluates single line numeric expressions with floating numbers,
unary operators + and - ,
left associative arithmetic operators + and - (lower priority), * and / (higher priority),
and ^ (highest priority, right associative).
You may use parentheses. You may define, redefine and use variables.
Undefined variables have the value NaN.
The variables pi and e are predefined.
Examples
12+99/3/-3
(12+99)/(3/-3)
2*4^0,5
pi
pi=355/113
3*pi+5
";

      /// <summary>
      /// The instance <see cref="InputClassifier"/> is used to read line by line,
      /// to assign each character (one after the other) to a class of symbols and
      /// to deliver it to <see cref="Lexer"/>
      /// </summary>
      private readonly MyInputClassifier InputClassifier;

      /// <summary>
      /// The instance <see cref="Lexer"/> is used to get characters from the <see cref="InputClassifier"/>
      /// and to recognize numbers, identifiers and characters used by <see cref="ReadAndAnalyze"/> 
      /// </summary>
      private readonly MyLexer Lexer;

      /// <summary>
      /// Constructor
      /// </summary>
      public ReadAndAnalyzeWithDynamicPriorites()
      {
         /* The parser uses a separately defined lexer to get its input,
          * the lexer uses a separately defined classifier to get ist input.
          */
         InputClassifier = new MyInputClassifier(_a);
         Lexer = new MyLexer(
             _a, // the attribute stack is defined by the base class GrammlatorApplication
             _s, // the state stack is defined by the base class GrammlatorApplication
             InputClassifier
             );
      }

      // This dictionary is used to store predefined and user defined identifiers and their values
      private Dictionary<string, double> DefinedNames;

      /// <summary>
      /// This method implements multiple calls of the calculator 
      /// </summary>
      public void ReadAndAnalyze()
      {
         Console.OutputEncoding = System.Text.Encoding.Unicode;

         Console.WriteLine(HowtoUse);

         DefinedNames
             = new Dictionary<string, double> {
                    { "pi", Math.PI },
                    { "e", Math.E }
             };

         // This input loop calls the method with code generated by grammlator
         while (true)
         {
            Console.WriteLine("Input a numeric expression or an empty line to stop the program:");

            // Look ahead one input symbol to check for empty line
            InputClassifier.PeekSymbol();
            if (InputClassifier.PeekSymbol() == ClassifierResult.EndOfLine)
            {
               break;
            }

            ReadAndAnalyzeExpression(); // <------------ this method contains the code generated by grammlator

            // ReadAndAnalyzeExpression will call the error handler, if it can not recognize a legal expression,
            // for example if you enter '#' (interpreted by myCharInput als "unknown"-Symbol)
            // Then some characters may remain in the input line.

            string RemainingCharacters = Lexer.GetRemainingCharactersOfLine();
            if (!string.IsNullOrEmpty(RemainingCharacters))
            {
               Console.WriteLine("Remaining characters ignored: '" + RemainingCharacters + "'");
               Console.WriteLine();
            }
         }
         Console.WriteLine("Good bye!");
      }

      /// <summary>
      /// This <see cref="ErrorHandler"/> is called by the generated code of ReadAndAnalyzeExpression() if an input symbol can not be accepted.
      /// </summary>
      /// <param name="numberOfState">The number of the state of the analysers the error occured in.</param>
      /// <param name="stateDescription">The description of the state of the analysers the error occured in.</param>
      /// <param name="symbol">The symbol which is not allowed in the given state</param>
      private bool ErrorHandler(int numberOfState, string stateDescription, LexerResult symbol)
      {
         // The symbol that caused the error has not been accepted.
         Debug.Assert(!Lexer.Accepted);
         // The symbol is given as parameter to avoid access to internals of Lexer
         Debug.Assert(symbol == Lexer.Symbol);
         Console.WriteLine(
             $"Parser error: illegal symbol \"{symbol.MyToString()}\" in parser state {numberOfState}:");
         Console.WriteLine(stateDescription, symbol);
         Console.WriteLine();
         return false; // return to generated code, which will set the stacks to correct states and then return
      }

      #region grammar
      //| /* Lines starting with //| contain grammar rules, which are evaluated by grammlator.
      //|    This is the second line of ReadAndAnalyze interpreted by grammlator.
      //|    Because the grammar may contain comments alike comments of C#
      //|    grammlator interprets these lines as comment. */
      //|
      //| /* The first grammlator instruction is the definition of prefixes used in the generated code 
      //|    (for example in "Lexer.PeekSymbol();" "if (Symbol == LexerResult.number)" and "Lexer.AcceptSymbol()"
      //|    and of the terminal symbols used in the grammar with their respectiv semantic attributes.
      //|    The names of the terminal symbols are used in the generated code as values of a C# enumeration. */
      //|
      //| // Compiler settings control how grammlator generates code (the names of the settings are not case sensitiv)
      //| IfToSwitchBorder: "5";
      //| Symbol: "Symbol" // the name of the variable used in the AssignSymbol instruction
      //| AssignSymbol: "Symbol = Lexer.PeekSymbol();" // the instruction to fetch a symbol
      //| AcceptSymbol: "Lexer.AcceptSymbol();" // the instruction to accept a symbol
      //| TerminalSymbolEnum: "LexerResult" // a prefix to be added to terminal symbol values
      //| StateDescription: "StateDescription" // the name of the variable which is the StateDescription assigned to
      //| ErrorHandlerMethod: "ErrorHandler" // the instruction to be executed in case of errors
      //|
      //| // Definition of the terminal symbols of the parser:
      //|      AddOp | SubOp | MultOp | DivOp | PowOp
      //|    | RightParentheses | EndOfLine | EqualChar
      //|    | LTChar | GTChar // these input symbols are not used 
      //|    | LeftParentheses | DecimalPoint 
      //|    | OtherCharacter(char c) 
      //|    | Number(double value) | Identifier (string identifier)
      /* Lines not starting with //| (even empty lines or C# comment lines) are interpreted as C# code associated to grammar rules. */
      enum CopyOfMyLexer_LexerResult {
         // These symbols are passed on from input to output (see Method PassSymbolOn(..)):
         AddOp, SubOp, MultOp, DivOp, PowOp,

         RightParentheses, EndOfLine, EqualChar,

         LTChar, GTChar, LeftParentheses,

         DecimalPoint, // DecimalPoint outside of (real) number

         OtherCharacter,  // (char c)

         // These symbols are computed by MySymbolInput.cs:
         Number, // (double value)
         Identifier // (string identifier)
      }

      /* Such a C# enum declaration (as shown above) may be appended to the definition of the terminal symbols.
       * This enum declaration is optional and redundant. 
       * If it is given, grammlator compares the names and positions of the elements
       * with the names and positions of the terminal symbols.
       * This is a recommended method to assure that the definitions of the terminal symbols 
       * of the grammar correspond exactly to the defintion in C#.
       */

      //| /* The following first grammar rule defines the special startsymbol "*"   */
      //| *= MyGrammar; // , EndOfLine;
      //|
      //| /* Because ", EndOfLine" is commented out, grammlator finds more conflicts,
      //|  * because "1" would be a valid input but also "1+2" and it is not defined
      //|  * in the second case whether the parser should stop after "1" or accept "+".
      //|  * In this case the below given constant priorities 101, -100 and -101
      //|  * will solve these conflicts.
      //|  */
      //|
      //|  /* Now - by standard grammar rules - we define nonterminal symbols as
      //|   * aliases for terminal symbols to improve readability.
      //|   * There is no special semantics associated with these special names (like "+")
      //|   * of nonterminal symbols.
      //|   */
      //|
      //|  "+" = AddOp; "-" = SubOp; "*" = MultOp; "/" = DivOp; "^" = PowOp;
      //|  ")" = RightParentheses; "=" = EqualChar; "(" = LeftParentheses;
      //|
      //| //  The next grammar rule defines the nonterminal symbol MyGrammar.
      //|
      //| MyGrammar = 
      //|    Expression(double result, string expression) ??-99?? // make expression "greedy"  
      private static void WriteResult(double result, string expression)
      {
         // The postfix variant has already been written
         Console.WriteLine(" (postfix notation);");

         Console.Write(expression);
         Console.WriteLine("(fully parenthesized infix notation);");

         Console.Write(" Result: ");
         Console.WriteLine(result);

         Console.WriteLine();
      }
      /* grammlator analyzes this C# method declaration, assigns it as semantic action
       * to the definition of MyGrammar and associates the methods formal parameter "double result"
       * with the attribute "double result" of the grammar symbol Expression.
       * ?-100? assigns a negative priority to this rule (see preceeding explanation).
       */

      //|    | Identifier(string identifier), Priority90, // don't accept identifier as expression if '=' follows
      //|            "=", Expression(double result, string expression) ??-91?? // make expression greedy
      private void AssignValueToIdentifier(string identifier, double result, string expression)
      {
         Console.WriteLine();
         if (DefinedNames.ContainsKey(identifier))
         {
            DefinedNames[identifier] = result;
            Console.WriteLine(expression);
            Console.WriteLine("Reassignment " + identifier + " = " + result);
         }
         else
         {
            Console.WriteLine(expression);
            DefinedNames.Add(identifier, result);
            Console.WriteLine("Assignment " + identifier + " = " + result);
         }
      }

      //| PrimaryExpression(double value, string expression)=
      //|      "(", Expression(double value, string expression), ")"
      void Parantheses(ref string expression)
      {
         expression = " (" + expression + ") ";
      }
      //|    | Number(double value)
      private static void Number(double value, out string expression)
      {
         expression = value.ToString();
         Console.Write(' ');
         Console.Write(value);
      }
      //|    | Identifier(string identifier)??-90?? // do not interpret identifier as expression if "=" follows (Priority90)
      private void IdentifierInExpression(out double value, out string expression, string identifier)
      {
         if (!DefinedNames.TryGetValue(identifier, out value))
            value = double.NaN;
         expression = value.ToString();
         Console.Write(' ');
         Console.Write(value);
      }

      //| unaryOperator(char c)=
      //|     "+"
      void UnaryPlus(out char c) => c = '+';
      //|   | "-"
      void UnaryMinus(out char c) => c = '-';
      //|
      //|
      //| binaryOperator(char c)=
      //|      "+"
      void PlusOp(out char c) => c = '+';
      //|    | "-"
      void MinusOp(out char c) => c = '-';
      //|    | "*"
      void MultOp(out char c) => c = '*';
      //|    | "/"
      void DivOp(out char c) => c = '/';
      //|    | "^"
      void PowOp(out char c) => c = '^';
      //|
      //|
      //|
      //|
      //| Expression(double value, string expression)= 
      //|      PrimaryExpression(double value, string expression)
      //|    | unaryOperator(char op), PrimaryExpression(double value2, string expression2)
      private static void UnaryExpression(out double value, out string expression, char op, double value2, string expression2)
      {
         switch (op)
         {
         case '+':
            value=value2;
            break;
         case '-':
            value = -value2;
            break;
         default:
            throw new ArgumentException();
         }
         expression = " (" + op + expression2 + ") ";
         Console.Write(' ');
         Console.Write(" u");
         Console.Write(op);
         return;
      }

      //|    | Expression(double value1, string expression1), OperatorPriority(int p), binaryOperator(char op),
      //|           Expression(double value2, string expression2)  ?? 
      //| // semantic priority:
      int BinaryExpressionPriority(int p, char op) => op == '^' ? p - 1 : p + 1; // '^' is left associative, the other operators are right associative
      //| // semantic method:
      private static void BinaryExp(out double value, out string expression, char op, double value1, double value2, string expression1, string expression2)
      {
         switch (op)
         {
         case '*':
            value = value1 * value2;
            break;
         case '/':
            value = value1 / value2;
            break;
         case '+':
            value = value1 + value2;
            break;
         case '-':
            value = value1 - value2;
            break;
         case '^':
            value = Math.Pow(value1, value2);
            break;
         default:
            throw new ArgumentException();
         }
         StringBuilder sb = new StringBuilder();

         // Output infix notation
         expression = sb.Append(" (").Append(expression1).Append(op).Append(expression2).Append(") ").ToString();

         Console.Write(sb.Clear().Append(' ').Append(op).ToString()); // Write postfix notation
      }

      //| /* The following nonterminal symbols, which produce the empty string, are defined to solve conflicts by priorities */
      //|
      //| OperatorPriority(int p) = ??
      int OperatorPriority() => PriorityOfPeek();
      int PriorityOfPeek()
      {
         switch (Lexer.PeekSymbol())
         {
         case LexerResult.AddOp:
         case LexerResult.SubOp:
            return 10;
         case LexerResult.MultOp:
         case LexerResult.DivOp:
            return 20;
         case LexerResult.PowOp:
            return 30;
         }
         throw new ArgumentException();
      }
      //| ??
      void ReturnOperatorPriority(out int p) => p = PriorityOfPeek();
      //| 
      //| Priority90= ??90??;
      //| 
      //| 
      #endregion grammar

      /***** The following few lines up to #region and the lines after #endregion are programmed manually *****/

      /// <summary>
      /// ReadAndAnalyzeExpression is generated by grammlator and implements the analyzer
      /// </summary>
      private void ReadAndAnalyzeExpression()
      {
         // We have to provide the variables which are used by the generated code:
         LexerResult Symbol;

#pragma warning disable IDE0059 // Der Wert, der dem Symbol zugeordnet ist, wird niemals verwendet.

         /***** The content of the region "grammlator generated" is (replaced and) inserted by grammlator *****/
#region grammlator generated Thu, 10 Sep 2020 21:15:58 GMT (grammlator, File version 2020.07.28.0 10.09.2020 21:15:48)
  Int32 StateStackInitialCount = _s.Count;
  Int32 AttributeStackInitialCount = _a.Count;
State1:
  const String StateDescription1 =
       "*Startsymbol= ►MyGrammar;";
  _s.Push(0);
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.AddOp)
     goto AcceptReduce1;
  if (Symbol <= LexerResult.SubOp)
     goto AcceptReduce2;
  if (Symbol == LexerResult.LeftParentheses)
     goto AcceptState11;
  if (Symbol == LexerResult.Number)
     {
     Lexer.AcceptSymbol();
     // Reduce3:
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Number(double value);◄ */
     _a.Allocate();

     Number(
        value: _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string
        );

     goto State3;
     }
  if (Symbol < LexerResult.Identifier)
     {
     if (ErrorHandler(1, StateDescription1, Symbol))
        {
        _s.Pop();
        goto State1;
        };
     goto EndWithError;
     }
  Debug.Assert(Symbol >= LexerResult.Identifier);
  Lexer.AcceptSymbol();
  // State7:
  /* MyGrammar= Identifier(string identifier), ►Priority90, "=", Expression(double result, string expression);
   * PrimaryExpression(double value, string expression)= Identifier(string identifier)●; */
  Symbol = Lexer.PeekSymbol();
  if (Symbol != LexerResult.EqualChar)
     // Reduce18:
     {
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Identifier(string identifier);◄ */
     _a.Allocate();

     IdentifierInExpression(
        value: out _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string,
        identifier: _a.PeekClear(-1)._string
        );

     goto State3;
     }
  Debug.Assert(Symbol == LexerResult.EqualChar);
State8:
  const String StateDescription8 =
       "MyGrammar= Identifier(string identifier), Priority90, ►\"=\", Expression(double result, string expression);";
  Symbol = Lexer.PeekSymbol();
  if (Symbol != LexerResult.EqualChar)
     {
     if (ErrorHandler(8, StateDescription8, Symbol))
        goto State8;
     goto EndWithError;
     }
  Debug.Assert(Symbol == LexerResult.EqualChar);
  Lexer.AcceptSymbol();
State9:
  const String StateDescription9 =
       "MyGrammar= Identifier(string identifier), Priority90, \"=\", ►Expression(double result, string expression);";
  _s.Push(3);
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.AddOp)
     goto AcceptReduce1;
  if (Symbol <= LexerResult.SubOp)
     goto AcceptReduce2;
  if (Symbol == LexerResult.LeftParentheses)
     goto AcceptState11;
  if (Symbol == LexerResult.Number)
     {
     Lexer.AcceptSymbol();
     // Reduce19:
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Number(double value);◄ */
     _a.Allocate();

     Number(
        value: _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string
        );

     goto State10;
     }
  if (Symbol < LexerResult.Identifier)
     {
     if (ErrorHandler(9, StateDescription9, Symbol))
        {
        _s.Pop();
        goto State9;
        };
     goto EndWithError;
     }
  Debug.Assert(Symbol >= LexerResult.Identifier);
  Lexer.AcceptSymbol();
  // Reduce20:
  /* aAdjust: 1
   * PrimaryExpression(double value, string expression)= Identifier(string identifier);◄ */
  _a.Allocate();

  IdentifierInExpression(
     value: out _a.PeekRef(-1)._double,
     expression: out _a.PeekRef(0)._string,
     identifier: _a.PeekClear(-1)._string
     );

State10:
  /* MyGrammar= Identifier(string identifier), Priority90, "=", Expression(double result, string expression)●;
   * Expression(double value, string expression)= Expression(double value1, string expression1), ►OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2); */
  Symbol = Lexer.PeekSymbol();
  if (Symbol >= LexerResult.RightParentheses)
     goto Reduce21;
  Debug.Assert(Symbol <= LexerResult.PowOp);
  // PrioritySelect3:
  // PriorityBranch3:
  /* Dynamic priority controlled actions */
  switch(Methods.IndexOfMaximum(-91,

     OperatorPriority()

     ))
  {
  case 0:
     goto Reduce21;
  }
Reduce9:
  /* aAdjust: 1
   * OperatorPriority(int p)= ;◄ */
  _a.Allocate();

  ReturnOperatorPriority(
     p: out _a.PeekRef(0)._int
     );

State4:
  const String StateDescription4 =
       "Expression(double value, string expression)= Expression(double value1, string expression1), OperatorPriority(int p), ►binaryOperator(char op), Expression(double value2, string expression2);";
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.AddOp)
     {
     Lexer.AcceptSymbol();
     // Reduce10:
     /* aAdjust: 1
      * binaryOperator(char c)= "+";◄ */
     _a.Allocate();

     PlusOp(
        c: out _a.PeekRef(0)._char
        );

     goto State5;
     }
  if (Symbol <= LexerResult.SubOp)
     {
     Lexer.AcceptSymbol();
     // Reduce11:
     /* aAdjust: 1
      * binaryOperator(char c)= "-";◄ */
     _a.Allocate();

     MinusOp(
        c: out _a.PeekRef(0)._char
        );

     goto State5;
     }
  if (Symbol <= LexerResult.MultOp)
     {
     Lexer.AcceptSymbol();
     // Reduce12:
     /* aAdjust: 1
      * binaryOperator(char c)= "*";◄ */
     _a.Allocate();

     MultOp(
        c: out _a.PeekRef(0)._char
        );

     goto State5;
     }
  if (Symbol <= LexerResult.DivOp)
     {
     Lexer.AcceptSymbol();
     // Reduce13:
     /* aAdjust: 1
      * binaryOperator(char c)= "/";◄ */
     _a.Allocate();

     DivOp(
        c: out _a.PeekRef(0)._char
        );

     goto State5;
     }
  if (Symbol > LexerResult.PowOp)
     {
     if (ErrorHandler(4, StateDescription4, Symbol))
        goto State4;
     goto EndWithError;
     }
  Debug.Assert(Symbol == LexerResult.PowOp);
  Lexer.AcceptSymbol();
  // Reduce14:
  /* aAdjust: 1
   * binaryOperator(char c)= "^";◄ */
  _a.Allocate();

  PowOp(
     c: out _a.PeekRef(0)._char
     );

State5:
  const String StateDescription5 =
       "Expression(double value, string expression)= Expression(double value1, string expression1), OperatorPriority(int p), binaryOperator(char op), ►Expression(double value2, string expression2);";
  _s.Push(2);
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.AddOp)
     goto AcceptReduce1;
  if (Symbol <= LexerResult.SubOp)
     goto AcceptReduce2;
  if (Symbol == LexerResult.LeftParentheses)
     goto AcceptState11;
  if (Symbol == LexerResult.Number)
     {
     Lexer.AcceptSymbol();
     // Reduce15:
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Number(double value);◄ */
     _a.Allocate();

     Number(
        value: _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string
        );

     goto State6;
     }
  if (Symbol < LexerResult.Identifier)
     {
     if (ErrorHandler(5, StateDescription5, Symbol))
        {
        _s.Pop();
        goto State5;
        };
     goto EndWithError;
     }
  Debug.Assert(Symbol >= LexerResult.Identifier);
  Lexer.AcceptSymbol();
  // Reduce16:
  /* aAdjust: 1
   * PrimaryExpression(double value, string expression)= Identifier(string identifier);◄ */
  _a.Allocate();

  IdentifierInExpression(
     value: out _a.PeekRef(-1)._double,
     expression: out _a.PeekRef(0)._string,
     identifier: _a.PeekClear(-1)._string
     );

State6:
  /* Expression(double value, string expression)= Expression(double value1, string expression1), ►OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2);
   * Expression(double value, string expression)= Expression(double value1, string expression1), OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2)●; */
  Symbol = Lexer.PeekSymbol();
  if (Symbol >= LexerResult.RightParentheses)
     goto Reduce17;
  Debug.Assert(Symbol <= LexerResult.PowOp);
  // PrioritySelect2:
  // PriorityBranch2:
  /* Dynamic priority controlled actions */
  switch(Methods.IndexOfMaximum(

     BinaryExpressionPriority(
        p: _a.PeekRef(-3)._int,
        op: _a.PeekRef(-2)._char
        ),

     OperatorPriority()

     ))
  {
  case 0:
     goto Reduce17;
  }
  goto Reduce9;

AcceptReduce1:
  Lexer.AcceptSymbol();
  // Reduce1:
  /* aAdjust: 1
   * unaryOperator(char c)= "+";◄ */
  _a.Allocate();

  UnaryPlus(
     c: out _a.PeekRef(0)._char
     );

State2:
  const String StateDescription2 =
       "Expression(double value, string expression)= unaryOperator(char op), ►PrimaryExpression(double value2, string expression2);";
  _s.Push(1);
  Symbol = Lexer.PeekSymbol();
  if (Symbol == LexerResult.LeftParentheses)
     goto AcceptState11;
  if (Symbol == LexerResult.Number)
     {
     Lexer.AcceptSymbol();
     // Reduce5:
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Number(double value);◄ */
     _a.Allocate();

     Number(
        value: _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string
        );

     goto Reduce7;
     }
  if (Symbol < LexerResult.Identifier)
     {
     if (ErrorHandler(2, StateDescription2, Symbol))
        {
        _s.Pop();
        goto State2;
        };
     goto EndWithError;
     }
  Debug.Assert(Symbol >= LexerResult.Identifier);
  Lexer.AcceptSymbol();
  // Reduce6:
  /* aAdjust: 1
   * PrimaryExpression(double value, string expression)= Identifier(string identifier);◄ */
  _a.Allocate();

  IdentifierInExpression(
     value: out _a.PeekRef(-1)._double,
     expression: out _a.PeekRef(0)._string,
     identifier: _a.PeekClear(-1)._string
     );

Reduce7:
  /* sAdjust: -1, aAdjust: -1
   * Expression(double value, string expression)= unaryOperator(char op), PrimaryExpression(double value2, string expression2);◄ */
  _s.Pop();

  UnaryExpression(
     value: out _a.PeekRef(-2)._double,
     expression: out _a.PeekRef(-1)._string,
     op: _a.PeekClear(-2)._char,
     value2: _a.PeekClear(-1)._double,
     expression2: _a.PeekRef(0)._string
     );

  _a.Free();
Branch1:
  switch (_s.Peek())
  {
  case 0:
     goto State3;
  case 1:
     goto Reduce7;
  case 2:
     goto State6;
  case 3:
     goto State10;
  /*case 4:
  default: break; */
  }
State12:
  const String StateDescription12 =
       "Expression(double value, string expression)= Expression(double value1, string expression1), ►OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2);\r\n"
     + "PrimaryExpression(double value, string expression)= \"(\", Expression(double value, string expression), ►\")\";";
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.PowOp)
     goto Reduce9;
  if (Symbol > LexerResult.RightParentheses)
     {
     if (ErrorHandler(12, StateDescription12, Symbol))
        goto State12;
     goto EndWithError;
     }
  Debug.Assert(Symbol == LexerResult.RightParentheses);
  Lexer.AcceptSymbol();
  // Reduce24:
  /* sAdjust: -1
   * PrimaryExpression(double value, string expression)= "(", Expression(double value, string expression), ")";◄ */
  _s.Pop();

  Parantheses(
     expression: ref _a.PeekRef(0)._string
     );

  goto Branch1;

Reduce8:
  /* aAdjust: -2
   * MyGrammar= Expression(double result, string expression);◄
   * then: *Startsymbol= MyGrammar;◄ */

  WriteResult(
     result: _a.PeekRef(-1)._double,
     expression: _a.PeekRef(0)._string
     );

  _a.Free(2);
ApplyStartsymbolDefinition1:
  // Halt: a definition of the startsymbol with 0 attributes has been recognized.
  _s.Pop();
  goto EndOfGeneratedCode;

State3:
  /* MyGrammar= Expression(double result, string expression)●;
   * Expression(double value, string expression)= Expression(double value1, string expression1), ►OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2); */
  Symbol = Lexer.PeekSymbol();
  if (Symbol >= LexerResult.RightParentheses)
     goto Reduce8;
  Debug.Assert(Symbol <= LexerResult.PowOp);
  // PrioritySelect1:
  // PriorityBranch1:
  /* Dynamic priority controlled actions */
  switch(Methods.IndexOfMaximum(-99,

     OperatorPriority()

     ))
  {
  case 0:
     goto Reduce8;
  }
  goto Reduce9;

AcceptState11:
  Lexer.AcceptSymbol();
State11:
  const String StateDescription11 =
       "PrimaryExpression(double value, string expression)= \"(\", ►Expression(double value, string expression), \")\";";
  _s.Push(4);
  Symbol = Lexer.PeekSymbol();
  if (Symbol <= LexerResult.AddOp)
     goto AcceptReduce1;
  if (Symbol <= LexerResult.SubOp)
     goto AcceptReduce2;
  if (Symbol == LexerResult.LeftParentheses)
     goto AcceptState11;
  if (Symbol == LexerResult.Number)
     {
     Lexer.AcceptSymbol();
     // Reduce22:
     /* aAdjust: 1
      * PrimaryExpression(double value, string expression)= Number(double value);◄ */
     _a.Allocate();

     Number(
        value: _a.PeekRef(-1)._double,
        expression: out _a.PeekRef(0)._string
        );

     goto State12;
     }
  if (Symbol < LexerResult.Identifier)
     {
     if (ErrorHandler(11, StateDescription11, Symbol))
        {
        _s.Pop();
        goto State11;
        };
     goto EndWithError;
     }
  Debug.Assert(Symbol >= LexerResult.Identifier);
  Lexer.AcceptSymbol();
  // Reduce23:
  /* aAdjust: 1
   * PrimaryExpression(double value, string expression)= Identifier(string identifier);◄ */
  _a.Allocate();

  IdentifierInExpression(
     value: out _a.PeekRef(-1)._double,
     expression: out _a.PeekRef(0)._string,
     identifier: _a.PeekClear(-1)._string
     );

  goto State12;

AcceptReduce2:
  Lexer.AcceptSymbol();
  // Reduce2:
  /* aAdjust: 1
   * unaryOperator(char c)= "-";◄ */
  _a.Allocate();

  UnaryMinus(
     c: out _a.PeekRef(0)._char
     );

  goto State2;

Reduce17:
  /* sAdjust: -1, aAdjust: -4
   * Expression(double value, string expression)= Expression(double value1, string expression1), OperatorPriority(int p), binaryOperator(char op), Expression(double value2, string expression2);◄ */
  _s.Pop();

  BinaryExp(
     value: out _a.PeekRef(-5)._double,
     expression: out _a.PeekRef(-4)._string,
     op: _a.PeekRef(-2)._char,
     value1: _a.PeekRef(-5)._double,
     value2: _a.PeekRef(-1)._double,
     expression1: _a.PeekRef(-4)._string,
     expression2: _a.PeekRef(0)._string
     );

  _a.Free(4);
  goto Branch1;

Reduce21:
  /* sAdjust: -1, aAdjust: -3
   * MyGrammar= Identifier(string identifier), Priority90, "=", Expression(double result, string expression);◄
   * then: *Startsymbol= MyGrammar;◄ */
  _s.Pop();

  AssignValueToIdentifier(
     identifier: _a.PeekRef(-2)._string,
     result: _a.PeekRef(-1)._double,
     expression: _a.PeekRef(0)._string
     );

  _a.Free(3);
  goto ApplyStartsymbolDefinition1;

EndWithError:
  // This point is reached after an input error has been found
  _s.Discard(_s.Count - StateStackInitialCount);
  _a.Free(_a.Count - AttributeStackInitialCount);

EndOfGeneratedCode:
  ;

#endregion grammlator generated Thu, 10 Sep 2020 21:15:58 GMT (grammlator, File version 2020.07.28.0 10.09.2020 21:15:48)
         /**** This line and the lines up to the end of the file are written by hand  ****/
#pragma warning restore IDE0059 // Der Wert, der dem Symbol zugeordnet ist, wird niemals verwendet.
      }
   }
}
