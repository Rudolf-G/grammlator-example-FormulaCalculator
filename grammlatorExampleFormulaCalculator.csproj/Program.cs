using System;
using System.Collections.Generic;

namespace GrammlatorExampleFormulaCalculator {
   /* This program demonstrates how a LALR(1)-grammar can be combined with C# methods
    * which are translated to C# code by grammlator.
    * It is not intended to be a comfortable user friendly program.
    * 
    * The comments describe the general structure of grammlator input.
    * As can be seen grammlator inserts the produced verbose code 
    * in a special region of the source files ReadAndAnalyze... (two versions) and MyLexer.
    * The parser verwsions and the lexer hav been programmed using a grammar as control structure.
    * 
    * This example uses some essential features of grammlator
    * such as C# typed attributes of terminal and nonterminal symbols,
    * ambiguous rules (to reflect the ambiguity of numerical expressions),
    * static priorities (one version of the lexer) and
    * dynamic priorities (the other version of the lexer) of grammar rules
    * to solve these ambiguities according to operator precedence and associativity.
    * 
    * To understand the effect of priorities assigned to definitions of nonterminal symbols
    * some knowledge of how LR-parsing works is requiered. grammlator helps to understand
    * the conflicts by detailed protocols showing in which states which conflicts have been found.
    * 
    * The precompiler grammlator is published in https://github.com/Rudolf-G/grammlator20
    */
   internal static class Program {
      private static void Main()
      {
         Console.OutputEncoding = System.Text.Encoding.Unicode;
         Console.WriteLine(HowtoUse);

         var DefinedNames
            = new Dictionary<string, double>
                {
                    { "pi", Math.PI },
                    { "e", Math.E }
                };


         InputOutputLoop(DefinedNames);
      }

      /// <summary>
      /// This input loop calls ReadAndAnalyzeExpression with code generated by grammlator
      /// </summary>
      /// <param name="DefinedNames"></param>
      private static void InputOutputLoop(Dictionary<string, double> DefinedNames)
      {
         // This input loop calls the method with code generated by grammlator
         while (true)
         {
            Console.WriteLine("Input a numeric expression or an empty line to stop the program:");

            string Line = Console.ReadLine();
            if (Line.Length==0)
            {
               break;
            }

            var example = new ReadAndAnalyzeWithDynamicPriorites(Line);
            // var example = ReadAndAnalyzeWithStaticPriorities();
            example.ReadAndAnalyzeExpression(DefinedNames); // <------------ this method contains the code generated by grammlator

            // ReadAndAnalyzeExpression will call the error handler, if it can not recognize a legal expression,
            // for example if you enter '#' (interpreted by myCharInput als "unknown"-Symbol)
            // Then some characters may remain in the input line.

            //string RemainingCharacters = Lexer.GetRemainingCharactersOfLine();
            //if (!string.IsNullOrEmpty(RemainingCharacters))
            //{
            //   Console.WriteLine("Remaining characters ignored: '" + RemainingCharacters + "'");
            //   Console.WriteLine();
            //}
         }
         Console.WriteLine("Good bye!");
      }

      private const string HowtoUse =
@"This calculator evaluates single line numeric expressions with floating numbers,
unary operators + and - ,
left associative arithmetic operators + and - (lower priority), * and / (higher priority),
and ^ (highest priority, right associative). You may use parentheses.

You may define, redefine and use variables.
The variables pi and e are predefined. Undefined variables have the value NaN.

Examples:
12+99/3/-3
(12+99)/(3/-3)
2*4^0,5
pi
pi=355/113
3*pi+5
";


   }
}

