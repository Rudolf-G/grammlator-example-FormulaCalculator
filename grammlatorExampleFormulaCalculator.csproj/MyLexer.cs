using System.Diagnostics;
using GrammlatorRuntime;
using System;
using System.Collections.Generic;

namespace GrammlatorExampleFormulaCalculator
{
    /// <summary>
    /// The enum <see cref="LexerResult"/> defines the set of values which can be assigned to this.Symbol by semantic methods.
    /// These identifiers and their order are used in the generated code in ReadAndAnalyze for comparisions (== but also &lt;, &gt;=, &gt;=, &gt;)
    /// </summary>
    public enum LexerResult
    {
        // These symbols are passed on from input to output (see Method PassSymbolOn(..)):
        AddOp, SubOp, MultOp, DivOp, PotOp,

        RightParentheses, Eol, EqualChar,

        Unknown, LTChar, GTChar,

        LeftParentheses,
        // These symbols are computed by MySymbolInput.cs:
        Number, Identifier
    }

    public static class LexerResultExtensions
    {
        /// <summary>
        /// Convert the enum value to a one character string if appropriate else to the name of the value
        /// </summary>
        /// <param name="r">The enum value</param>
        /// <returns>The string to dispaly the enum value</returns>
        public static string MyToString(this LexerResult r)
        {
            // Assign a character to each value of LexerResult or assign 'x'
            const string MyDisplay = "+-*/^)x=x<>(xx";
            char result = MyDisplay[(int)r];

            if (result != 'x')
                return result.ToString();
            else
                return r.ToString();
        }
    }

    public class MyLexer : GrammlatorInputApplication<LexerResult>
    {
        /// <summary>
        /// The MyCharacterInputClass provides the input for MySymbolInputClass
        /// </summary>
        private readonly MyInputClassifier InputClassifier;

        // Constructor
        /// <summary>
        /// Constructor of MyLexer
        /// </summary>
        /// <param name="attributeStack">grammlator uses the attributeStack a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any) and c) to get the attribute of input symbols
        /// </param>
        /// <param name="stateStack">the code generated by grammlator may need a state stack, which can be shared. 
        /// </param>
        /// <param name="inputClassifier"></param>
        /// <param name="externalErrorHandler"></param>
        public MyLexer(
            MultiTypeStack attributeStack,
            Stack<Int32> stateStack,
            MyInputClassifier inputClassifier,
            Action<int, string, string> externalErrorHandler)
            : base(attributeStack, stateStack)
        {
            InputClassifier = inputClassifier;
            ExternalErrorHandler = externalErrorHandler;
        }

        private readonly Action<int, string, string> ExternalErrorHandler;

        // The GetRemainigCharactersOfLine method is specific to this example

        /// <summary>
        /// This method positions the input behind the end of the actual input line and returns the string of skipped characters.
        /// </summary>
        /// <returns>The string of skipped characters (without eol). Maybe the empty string.</returns>
        public string GetRemainingCharactersOfLine()
        {
            AcceptSymbol();
            return InputClassifier.GetRemainigCharactersOfLine();
        }

        private void ErrorHandler(int i, string stateDescription, ClassifierResult symbol)
        {
            /* A lexical error will occur, if the first character is a decimal point 
             * or if a character other than a digit follows a decimal point.
             * If the grammar would allow numbers with decimal point but no digits in front or after the decimal point
             * no errors would occur.
             */
            // Call the error handler defined by the constructor
            ExternalErrorHandler(i, stateDescription, symbol.MyToString());
            // Return "Unknown" as the result of this call of the lexical analyzer
            Symbol = LexerResult.Unknown;
        }

        #region grammar
        //| /* This is the first line of MySymbolInput interpreted by the grammlator System. It is interpreted as comment.
        //|    All lines, which contain grammar rules start with //|. They appear as comment to the C# compiler.
        //|    The first line of the grammar lists the prefixes to be used for comparision of symbols
        //|    in the generated code (for example in MyCharacterInput.Symbol == eCharGroup.letter),
        //|    followed by a list of all terminal symbols in correct order as given by the enum declaration in cMyCharacterInput.
        //|    There in addition the attributes of each terminal symbol must be specified exactly as provided by MyCharacterInput.
        //| */
        //|
        //| // Compiler settings
        //| Symbol: "Symbol"
        //| AssignSymbol: "Symbol = InputClassifier.PeekSymbol();"
        //| AcceptSymbol: "InputClassifier.AcceptSymbol();"
        //| TerminalSymbolEnum: "ClassifierResult"
        //| ErrorHandlerCall: "ErrorHandler(ErrorStateNumber, StateDescription, Symbol);"
        //|
        //| // Definition of the terminal input symbols of the lexer
        //|      AddOp | SubOp | MultOp | DivOp | PotOp 
        //|    | RightParentheses | Eol | EqualChar 
        //|    | Unknown(char c) | LTChar | GTChar
        //|    | LeftParentheses  
        //|    | Digit(char c) | Letter(char c) | DecimalPoint 

        /* The C# enum at this place is optional. If present it must conicide with the terminal definitions above. */
        public enum CopyOfClassifierResult
        {
            AddOp, SubOp, MultOp, DivOp, PotOp,

            RightParentheses, Eol, EqualChar,

            Unknown, LTChar, GTChar,

            LeftParentheses,

            Digit, Letter, DecimalPoint
        };

        //|    /* The attributes of the terminal symbols are defined by a type identifier and an attribute identifier.
        //|       The attribute type must be exactly as given by MyCharacterInput. The identifier has only documentary purposes.
        //|
        //|       The following first grammar rule defines the Startsymbol, which is identified by * and can not be used as a nonterminal symbol.
        //|       When a definition of the startsymbol is recognized its attributes are considered to be attributes of the symbol which is
        //|       returned as result of FetchSymbol() defined below.
        //|      */
        //|
        //| *=   // C# definition of the symbols which MySymbolInput may recognize. The C# code in the following lines can also be placed outside of the grammar.
        //|       Number(double value) 
        private void AssignNumberToSymbol()
        {
            Symbol = LexerResult.Number; // value will be assigned by grammlator generated code
        }

        //|            // the priority <0 ensures that not only the first of a sequence of letters and digits is interpreted as number
        //|       | Identifier(string identifier)  ?-1? 
        private void AssignIdentifierToSymbol()
        {
            Symbol = LexerResult.Identifier; // identifier will be assigned by grammlator generated code
        }

        //|       | SymbolToPassOn
        private void PassSymbolOn()
        {
            /* This is a short but not trivial solution to pass input symbols as result to the calling method.
             * Precondition is the consistent definition of the enumerations LexerResult and CharGroupEnum
             * and the knowledge, that there has been no look ahead */
            Symbol = (LexerResult)(InputClassifier.Symbol);
        }

        //|    | Unknown(char c)
        private void PassUnknownOn()
        {
            Symbol = LexerResult.Unknown;
        }

        //| SymbolToPassOn=
        //|         Eol
        //|       | LTChar 
        //|       | GTChar
        //|       | EqualChar 
        //|       | AddOp
        //|       | SubOp 
        //|       | MultOp
        //|       | DivOp
        //|       | PotOp
        //|       | RightParentheses
        //|       | LeftParentheses

        //| integer(double value, int length)= 
        //|    Digit(char c)
        private static void FirstdigitOfNumberRecognized(out double value, out int length, char c)
        {
            value = (int)c - (int)'0';
            length = 1;
        }

        //|    | integer(double value, int length), Digit(char nextDigit) 
        private static void IntegerFollowedByDigitRecognized(ref double value, ref int length, char nextDigit)
        {
            value = (value * 10) + ((int)nextDigit - (int)'0');
            length++;
        }

        //| Number(double value)=
        //|       integer(double value, int notUsed)?-10?
        //|     | integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits)?-11?
        private static void NumberWithDigitsRecognized(ref double value, double valueOfDigits, int numberOfDigits)
        {
            value += (valueOfDigits / System.Math.Pow(10, numberOfDigits));
        }

        //| Identifier(string identifier)=
        //|       Letter(char c)
        private static void FirstCharOfIdentifierRecognized(out string identifier, char c)
        {
            identifier = c.ToString();
        }
        //|     | Identifier(string identifier), letterOrDigit(char c)
        private static void OneMoreCharacterOfIdentifierRecognized(ref string identifier, char c)
        {
            identifier += c.ToString();
        }

        //| letterOrDigit(char c)=  // special case of overlapping attributes. No method needed.
        //|       Letter(char c)
        //|     | Digit(char c )

        #endregion grammar

        //  The following few lines up to "#region grammlator generated ..." and the lines after #endregion are programmed manually

        public override LexerResult PeekSymbol()
        {
            if (!Accepted)
                return (LexerResult)this.Symbol;
            Accepted = false;

            String StateDescription;
            ClassifierResult Symbol;
            Int32 ErrorStateNumber;

            /***** the contens of the region "grammlator generated" are (replaced and) inserted by grammlator *****/
#region grammlator generated 05.07.2019 by Grammlator version 0:21 (build 05.07.2019 22:50:10 +00:00)
  Int32 AttributeStackInitialCount = _a.Count;
  // State 1
  StateDescription =
       "*Startsymbol= ►Number(double value);\r\n"
     + "*Startsymbol= ►Identifier(string identifier);\r\n"
     + "*Startsymbol= ►SymbolToPassOn;\r\n"
     + "*Startsymbol= ►Unknown(char c);";
  Symbol = InputClassifier.PeekSymbol();
  if (Symbol == ClassifierResult.DecimalPoint)
     {
     ErrorStateNumber = 1;
     goto x1;
     }
  if (Symbol == ClassifierResult.Unknown)
     {
     InputClassifier.AcceptSymbol();
     /* Reduction 2
      * *Startsymbol= Unknown(char c);◄ method: PassUnknownOn, aStack: -1
      */

     PassUnknownOn();

     goto h2;
     }
  if (Symbol == ClassifierResult.Digit)
     {
     InputClassifier.AcceptSymbol();
     /* Reduction 3, aStack: 1
      * integer(double value, int length)= Digit(char c);◄ aStack: 1, method: FirstdigitOfNumberRecognized
      */
     _a.Allocate();

     FirstdigitOfNumberRecognized(
        value: out _a.PeekRef(-1)._double,
        length: out _a.PeekRef(0)._int,
        c: _a.PeekClear(-1)._char
        );

     goto s2;
     }
  if (Symbol == ClassifierResult.Letter)
     {
     InputClassifier.AcceptSymbol();
     /* Reduction 4
      * Identifier(string identifier)= Letter(char c);◄ method: FirstCharOfIdentifierRecognized
      */

     FirstCharOfIdentifierRecognized(
        identifier: out _a.PeekRef(0)._string,
        c: _a.PeekClear(0)._char
        );

     goto s5;
     }
  Debug.Assert(Symbol != ClassifierResult.Unknown
     && Symbol < ClassifierResult.Digit);
  InputClassifier.AcceptSymbol();
  /* Reduction 1
   * *Startsymbol= SymbolToPassOn;◄ method: PassSymbolOn
   */

  PassSymbolOn();

  // Halt: a definition of the startsymbol with 0 attributes has been recognized.
  goto EndOfGeneratedCode;
s2:
  // State 2
  StateDescription =
       "Number(double value)= integer(double value, int notUsed)●;\r\n"
     + "Number(double value)= integer(double value, int notUsed), ►DecimalPoint, integer(double valueOfDigits, int numberOfDigits);\r\n"
     + "integer(double value, int length)= integer(double value, int length), ►Digit(char nextDigit);";
  Symbol = InputClassifier.PeekSymbol();
  if (Symbol == ClassifierResult.Digit)
     {
     InputClassifier.AcceptSymbol();
     /* Reduction 7, aStack: -1
      * integer(double value, int length)= integer(double value, int length), Digit(char nextDigit);◄ method: IntegerFollowedByDigitRecognized, aStack: -1
      */

     IntegerFollowedByDigitRecognized(
        value: ref _a.PeekRef(-2)._double,
        length: ref _a.PeekRef(-1)._int,
        nextDigit: _a.PeekRef(0)._char
        );

     _a.Free();
     goto s2;
     }
  if (Symbol == ClassifierResult.DecimalPoint)
     {
     InputClassifier.AcceptSymbol();
     // State 3
     StateDescription =
          "Number(double value)= integer(double value, int notUsed), DecimalPoint, ►integer(double valueOfDigits, int numberOfDigits);";
     Symbol = InputClassifier.PeekSymbol();
     if (Symbol != ClassifierResult.Digit)
        {
        ErrorStateNumber = 3;
        goto x1;
        }
     Debug.Assert(Symbol == ClassifierResult.Digit);
     InputClassifier.AcceptSymbol();
     /* Reduction 8, aStack: 1
      * integer(double value, int length)= Digit(char c);◄ aStack: 1, method: FirstdigitOfNumberRecognized
      */
     _a.Allocate();

     FirstdigitOfNumberRecognized(
        value: out _a.PeekRef(-1)._double,
        length: out _a.PeekRef(0)._int,
        c: _a.PeekClear(-1)._char
        );

     goto s4;
     }
  Debug.Assert(Symbol != ClassifierResult.Digit
     && Symbol != ClassifierResult.DecimalPoint);
  /* Reduction 6, aStack: -1
   * Number(double value)= integer(double value, int notUsed);◄ Priority: -10, aStack: -1
   */
  _a.Free();
r5:
  /* Reduction 5
   * *Startsymbol= Number(double value);◄ method: AssignNumberToSymbol, aStack: -1
   */

  AssignNumberToSymbol();

h2:
  // Halt: a definition of the startsymbol with 1 attributes has been recognized.
  AttributesOfSymbol.CopyAndRemoveFrom(_a, 1);
  goto EndOfGeneratedCode;
s4:
  // State 4
  StateDescription =
       "Number(double value)= integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits)●;\r\n"
     + "integer(double value, int length)= integer(double value, int length), ►Digit(char nextDigit);";
  Symbol = InputClassifier.PeekSymbol();
  if (Symbol != ClassifierResult.Digit)
     {
     /* Reduction 9, aStack: -3
      * Number(double value)= integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits);◄ Priority: -11, method: NumberWithDigitsRecognized, aStack: -3
      */

     NumberWithDigitsRecognized(
        value: ref _a.PeekRef(-3)._double,
        valueOfDigits: _a.PeekRef(-1)._double,
        numberOfDigits: _a.PeekRef(0)._int
        );

     _a.Free(3);
     goto r5;
     }
  Debug.Assert(Symbol == ClassifierResult.Digit);
  InputClassifier.AcceptSymbol();
  /* Reduction 10, aStack: -1
   * integer(double value, int length)= integer(double value, int length), Digit(char nextDigit);◄ method: IntegerFollowedByDigitRecognized, aStack: -1
   */

  IntegerFollowedByDigitRecognized(
     value: ref _a.PeekRef(-2)._double,
     length: ref _a.PeekRef(-1)._int,
     nextDigit: _a.PeekRef(0)._char
     );

  _a.Free();
  goto s4;

s5:
  // State 5
  StateDescription =
       "*Startsymbol= Identifier(string identifier)●;\r\n"
     + "Identifier(string identifier)= Identifier(string identifier), ►letterOrDigit(char c);";
  Symbol = InputClassifier.PeekSymbol();
  if (Symbol != ClassifierResult.Digit && Symbol != ClassifierResult.Letter)
     {
     /* Reduction 11
      * *Startsymbol= Identifier(string identifier);◄ Priority: -1, method: AssignIdentifierToSymbol, aStack: -1
      */

     AssignIdentifierToSymbol();

     goto h2;
     }
  Debug.Assert(Symbol == ClassifierResult.Digit || Symbol == ClassifierResult.Letter);
  InputClassifier.AcceptSymbol();
  /* Reduction 12, aStack: -1
   * Identifier(string identifier)= Identifier(string identifier), letterOrDigit(char c);◄ method: OneMoreCharacterOfIdentifierRecognized, aStack: -1
   */

  OneMoreCharacterOfIdentifierRecognized(
     identifier: ref _a.PeekRef(-1)._string,
     c: _a.PeekRef(0)._char
     );

  _a.Free();
  goto s5;

x1:
  // This point is reached after an input error has been found
  ErrorHandler(ErrorStateNumber, StateDescription, Symbol);
  _a.Free(_a.Count - AttributeStackInitialCount);

EndOfGeneratedCode:
     ;
#endregion grammlator generated 05.07.2019 by Grammlator version 0:21 (build 05.07.2019 22:50:10 +00:00)

            return (LexerResult)(this.Symbol);
        }
    }
}
