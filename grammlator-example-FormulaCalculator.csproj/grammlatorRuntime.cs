namespace GrammlatorRuntime {
    /* The grammlator runtime library provides interfaces and classes that may be used
     * to implement grammlator applications.
     */

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.InteropServices; // to overlay fields of the elements of the attribute array
    using System.Text;

    /* Interface IGrammlatorInput:
     * This interface may be used to check that a method defines all methods
     * grammlater generated applications need for symbol input.
     * You will find more information on the interface methods in the class definitions below, 
     * which may be used as base classes instead of using the interfaces.
     */

    /// <summary>
    /// The code generated by grammlator gets its input by the methods specified by this interface.
    /// </summary>
    /// <typeparam name="TypeOfSymbol">Type of the "Symbol" the instance makes available</typeparam>
    public interface IGrammlatorInput<TTypeOfOutputSymbols> where TTypeOfOutputSymbols : IComparable /* enum */ {
        TTypeOfOutputSymbols Symbol { get; }
        bool Accepted { get; }
        AttributeStack _a { get; }
        void AcceptSymbol();
        void FetchSymbol();
        }

    /* Base classes
     *   CgrammlatorApplication
     *   CgrammlatorInput
     *   cGrammlatorInputApplication
     */

    /// <summary>
    /// Abstract base class for classes that provide input for grammlator generated code
    /// </summary>
    /// <typeparam name="TTypeOfOutputSymbols">the type of Symbol</typeparam>
    public abstract class GrammlatorInput<TTypeOfOutputSymbols>
        : IGrammlatorInput<TTypeOfOutputSymbols> where TTypeOfOutputSymbols : IComparable  /* enum */ {

        /// <summary>
        /// grammlator uses the attributeStack
        /// a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any)
        /// c) to get the attribute of input symbols
        /// Access to the elements of the attribute stack is not type save.
        /// </summary>
        public AttributeStack _a { get; protected set; } // Check: access from semantic methods is not type save

        /// <summary>
        /// Constructor of cGrammlatorInputApplication
        /// </summary>
        /// <param name="attributeStack">grammlator uses the attributeStack a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any) and c) to get the attribute of input symbols
        /// </param>
        protected GrammlatorInput(AttributeStack attributeStack) {
            _a = attributeStack;
            Accepted = true;
            }

        /// <summary>
        /// After the first call of FetchSymbol() the field Symbol will have a defined value.  The value can only be changed by FetchSymbol().
        /// Symbol typically is used in comparisions in generated code.
        /// </summary>
        public TTypeOfOutputSymbols Symbol { get; protected set; }

        /// <summary>
        /// When accepted is false, then calls to FetchSymbol() do nothing, calls to AcceptSymbol() push all the attributes of Symbol to the attribute stack and set accepted to true.
        /// When accepted is true, then calls to AcceptSymbol() do nothing, calls to FetchSymbol() retrieve the next symbol and set accepted to false. 
        /// </summary>
        public bool Accepted
            {
            get; // may be evaluated in semantic methods before accessing context
            protected set;
            }

        /// <summary>
        /// A local stack with the attributes of Symbol (if any). It is empty if accepted == true.
        /// </summary>
        private AttributeStack _AttributesOfSymbol = new AttributeStack(10);
        protected AttributeStack AttributesOfSymbol
            {
            get { return _AttributesOfSymbol; }
            // private set{ _AttributesOfSymbol = value; }
            }

        /// <summary>
        /// Do nothing, if accepted==true. Else set accepted=true and copy the AttributesOfSymbol to the attribute stack. 
        /// </summary>
        public virtual void AcceptSymbol() { // Symbol akzeptieren und Attribute kellern
            if (Accepted) return;
            Accepted = true;
            // TODO update input position <-------------------------------------------------------
            _a.CopyAndRemoveFrom(AttributesOfSymbol);
            }

        /// <summary>
        /// if accepted==true compute the next Symbol, push its attributes to AttributesOfSymbol and set accepted to false, else do nothing
        /// </summary>
        public abstract void FetchSymbol();
        }

    /// <summary>
    /// Abstract base class for classes that use grammlator generated code
    /// </summary>
    /// <typeparam name="TypeOfOutputSymbols"></typeparam>
    public abstract class GrammlatorApplication {

        /// <summary>
        /// grammlator uses the attributeStack 
        /// a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any) and 
        /// c) to get the attribute of input symbols
        /// Access to its elements is not type save.
        /// </summary>
        public AttributeStack _a { get; protected set; } // Check: access from semantic methods is not type save

        /// <summary>
        /// the state stack is used by grammlator generated code. Each class may have its own state stack. Different classes may share the same state stack.
        /// </summary>
        protected StateStack _s { get; }

        /// <summary>
        /// Constructor of cGrammlatorInputApplication
        /// </summary>
        /// <param name="attributeStack">grammlator uses the attributeStack a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any) and c) to get the attribute of input symbols
        /// </param>
        /// <param name="stateStack">the code generated by grammlator may need a state stack, which can be shared. 
        /// If no state stack is specified in the constructor, then a local state stack will be used.
        /// </param>
        protected GrammlatorApplication(int initialSizeOfAttributeStack = 10, int initialSizeOfStateStack = 10) {
            _a = new AttributeStack(initialSizeOfAttributeStack);
            _s = new GrammlatorRuntime.StateStack(initialSizeOfStateStack);
            }
        }


    /// <summary>
    /// Abstract base class for classes that provide input for grammlator generated code
    /// and that that use grammlator generated code for their owm implementation
    /// </summary>
    /// <typeparam name="TTypeOfOutputSymbols"></typeparam>
    public abstract class GrammlatorInputApplication<TTypeOfOutputSymbols>
        : GrammlatorInput<TTypeOfOutputSymbols> where TTypeOfOutputSymbols : IComparable  /* enum */  {

        /// <summary>
        /// the state stack is used by grammlator generated code. Each class may have its own state stack. Different classes may share the same state stack.
        /// </summary>
        protected StateStack _s { get; }

        /// <summary>
        /// Constructor of cGrammlatorInputApplication
        /// </summary>
        /// <param name="attributeStack">grammlator uses the attributeStack a) in grammlator generated code 
        /// b) to return the attributes of output symbol (if any) and c) to get the attribute of input symbols
        /// </param>
        /// <param name="stateStack">the code generated by grammlator may need a state stack, which can be shared. 
        /// If no state stack is specified in the constructor, then a local state stack will be used.
        /// </param>
        protected GrammlatorInputApplication(AttributeStack attributeStack, StateStack stateStack) : base(attributeStack) {
            _s = stateStack;
            }

        }

    /*          c S t a t e S t a c k          */

    /// <summary>
    /// The state stack is used to push integer values assigned to states. When a production is recognized,
    /// processing continues depending on the contents of the state stack. Depending on optimization
    /// the same number may be assigned to different states. There may be states with no assigned number.
    /// </summary>
    public class StateStack: Stack<int> {

        public StateStack(int capacity) : base(capacity) {; }
        public StateStack() : base() {; }

        /// <summary>
        /// "x=Pop(1);" is eqivalent to "x=Pop();".  "x=Pop(2);" is equivalent to "Pop(); x=Pop();" and so on.
        /// Pop(i) is executed, when a reduction goes back over n states, with i of them having assigned values.
        /// </summary>
        /// <param name="count">number of elements to remove from the stack</param>
        /// <returns>last element removed</returns>
        public int Pop(int count) {
            for (int i = 1; i < count; i++) // count-1 Pop, i = 1 to avoid overflow
                base.Pop();
            return base.Pop(); // one additional Pop
            }

        }


    /*          s A t t r i b u t e  and  c A t t r i b u t e S t a c k          */

    /* The attribute stack provides indexed acccess to its elements by methods used as actions of grammar rules.
     * grammlater generates method calls, which use elements of the attribute stack as out, ref or value parameters.
     * Unfortunately C# neither allows a C# indexer nor a property to be used as a ref or out Parameter.

     * Attributes of the left side and of the right side of a production overlay in the stack of attributes.
     * To avoid access conflicts attributes of the right side are translated to value parameters, so that
     * the methods get a copy of the value. Attributes of the left side are translated to out parameters,
     * so that the method can assign values.
     * In special cases (overlapping attributes with identical identifiers and identical types) ref parameters
     * are used.
     */

    /// <summary>
    /// Each element of the attribute stack stores one attribute of the actually processed productions of the grammar.
    /// Only one of the different fields of each stackelement is used at the same time.
    /// The other fields contain old or undefined values and may be overwritten by random binary patterns.
    /// </summary>
    [StructLayout(LayoutKind.Explicit)]
    public partial struct AttributeStruct { // must be extended by "partial" declarations

        /* It is possible, to overlap fields with different object types.
         * Not all errors caused by different overlapping object-types are recognized by the C# compiler or the C# runtime system.
         * Storing an object in one field and accessing the object by an other typed object field 
         * will result in very hard to recognize errors in the behaviour of the program.
         */
        //[FieldOffset(0)]
        //public object _object; // an example of an object field
        //[FieldOffset(0)]       // _string uses the same memory location as _double 
        //public string _string; // an example of a overlapping object field
        //[FieldOffset(8)]       // value fields must not overlap object fields
        //public double _double; // an example of a value field
        //[FieldOffset(8)]       // _int uses the same memory location as _double 
        //public int _int;       // an example of a overlapping value field

        }

    /// <summary>
    /// The attribute stack is used to store the attributes of grammar rules during the (recursive) analyzing process.
    /// </summary>
    public class AttributeStack: IEnumerable<AttributeStruct> {

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="initialCapacity">must be >= 0. Ff not specified, an implemenation specific value will be used</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
        public AttributeStack(int initialCapacity = 100) {
            if (initialCapacity < 0)
                throw new ArgumentOutOfRangeException("initialCapacity");
            a = new AttributeStruct[initialCapacity];
            x = -1; // empty stack, no top element a[x]
            }

        // For each type identifier used in the grammar there must be a corresponding field in the struct sStackelement.
        // The identifier of the corresponding field of a type starts with the character '_' followed by the identifier of the type.

        // By using System.Runtime.InteropServices [StructLayout(LayoutKind.Explicit)] it is possible 
        // to overlap different value-fields and different class-fields in the stack, so that aditional types do not use additional space.
        // This option is demonstrated in the following comments.

        // The grammlator runtime library does not contain predefined types.
        // All types used in the grammar are to be specified in a local partial definition.

        /// <summary>
        /// This array implements the stack of attributes. a[x] is the top of the stack.
        /// </summary>
        public AttributeStruct[] a; // a must be an array, not a property


        /// <summary>
        /// x is the index of the element on top of the stack a or -1 if the stack is empty
        /// </summary>
        public int x = -1; // empty stack, no top element a[x]

        /// <summary>
        /// Count returns the number of elements the stack contains (x+1)
        /// </summary>
        public int Count { get { return x + 1; } }

        /// <summary>
        /// Increment the stack pointer without modifying elements.
        /// Increment the capacity of the stack if required.
        /// </summary>
        /// <param name="increment">number by which the stack count is incremented</param>
        public void Reserve(int increment = 1) { // frühere Bezeichnung down(int anzahl)
            Debug.Assert(increment >= 0, "Argument of Reserve has to be >=0");
            x += increment;

            // increment the stack if it is not large enough (by a factor of 2)
            int newLength = a.Length;
            while (newLength <= x)
                newLength *= 2;

            if (newLength > a.Length)
                Array.Resize<AttributeStruct>(ref a, newLength);
            }

        /// <summary>
        /// Push one element on the stack
        /// </summary>
        /// <param name="elementToPush"></param>
        public void Push(AttributeStruct elementToPush) {
            Reserve(1);
            a[x] = elementToPush;
            }


        /// <summary>
        /// remove count elements from the stack: decrement index x after clearing the elements
        /// </summary>
        /// <param name="count">number of elements to remove >= 0</param>
        public AttributeStruct Pop(int count = 1) {
            Debug.Assert(count >= 0, "Argument of Pop has to be >=0 !");
            Debug.Assert(count <= Count, "Argument of Pop has to be <=Count !");
            // Verwerfen von nicht mehr benötigten Objektverweisen,
            // damit diese gegebenenfalls für Garbage-Collection freigegeben werden
            int lowindex = x + 1 - count; // index of the last popped element
            AttributeStruct result = a[lowindex];

            for (int i = x; i >= lowindex; i--) {
                a[i] = new AttributeStruct(); // clear discarded elements
                }
            x -= count;
            return result;
            }
        // TODO two different stacks for objects and for values
        /* The actual implementation of Pop is not perfect. For example in "A(int i): a(object o);"
         * the attributes i and o share the same stack element, which will not be discarded,
         * when a is reduced to A. The attribute i will be stored in the same stack element as o.
         * But in C# a value cannnot replace an object reference.
         * As solution a implementation of the compiler might use two different stacks,
         * one for values and one for objects. 
         * */

        /// <summary>
        /// Copy and remove count attributes from stack
        /// </summary>
        /// <param name="count">stack to copy from</param>
        public void CopyAndRemoveFrom(AttributeStack stack, int count) {
            Reserve(count);
            for (int i = 0; i < count; i++) {
                a[x - i] = stack.a[stack.x - i];
                }
            stack.Pop(count);
            }

        /// <summary>
        /// Copy and remove all attributes from stack
        /// </summary>
        /// <param name="count">stack to copy from</param>
        public void CopyAndRemoveFrom(AttributeStack stack) {
            CopyAndRemoveFrom(stack, stack.Count);
            }


        /// <summary>
        /// Stringbuilder used by GetString
        /// </summary>
        private StringBuilder GetStringStringBuilder = new StringBuilder(30); // will grow as needed

        /// <summary>
        /// Retrieves the string starting with a[StartIndex]._char and ending before (char)0 or at Index x, which occurs first
        /// </summary>
        /// <param name="startIndex">Index less than or equal to 1 + the index x of the last stack element</param>
        /// <returns>the string without (char)0 or the empty string</returns>
        public string GetString(int startIndex) { // Zurückgeben der ab Position x+offset im Keller gespeicherten nullterminierten Zeichenfolge als String
            Debug.Assert(startIndex <= x + 1);
            if (startIndex > x) return "";

            int EndIndex = Array.FindIndex<AttributeStruct>(a, startIndex, x - startIndex + 1, (AttributeStruct x) => x._char == (char)0);
            if (EndIndex == -1) EndIndex = x + 1; // if (char)0 not found proceed as it would be above top of stack

            int length = EndIndex - startIndex;
            GetStringStringBuilder.EnsureCapacity(length);

            for (int i = startIndex; i < EndIndex; i++) {
                GetStringStringBuilder.Append(a[i]._char);
                }

            string result = GetStringStringBuilder.ToString();
            GetStringStringBuilder.Clear();

            return result;
            }



        // Implementation of foreach by the IEnumerable and the IENumerator interfaces.
        // Not used by generated code. May be used for testing purposes.
        public IEnumerator GetEnumerator() {
            return (IEnumerator)this;
            }

        IEnumerator<AttributeStruct> IEnumerable<AttributeStruct>.GetEnumerator() {
            return new CAttributeStackEnumerator(this);
            }


        }

    class CAttributeStackEnumerator: IEnumerator<AttributeStruct> {
        int EnumeratePosition = -1;

        AttributeStack _a;
        public CAttributeStackEnumerator(AttributeStack attributeStack) {
            _a = attributeStack;
            }
        public bool MoveNext() {
            EnumeratePosition++;
            return EnumeratePosition <= _a.x;
            }
        public void Reset() { EnumeratePosition = -1; }
        object IEnumerator.Current { get { return _a.a[EnumeratePosition]; } } // boxes the return value

        AttributeStruct IEnumerator<AttributeStruct>.Current { get { return _a.a[EnumeratePosition]; } } // returns a struct
        void IDisposable.Dispose() { }

        }


    }