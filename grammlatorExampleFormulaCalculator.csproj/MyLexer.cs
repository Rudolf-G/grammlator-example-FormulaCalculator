using System.Diagnostics;
using GrammlatorRuntime;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace GrammlatorExampleFormulaCalculator {
   /// <summary>
   /// The enum <see cref="LexerResult"/> defines the set of values which can be assigned to this.Symbol by semantic methods.
   /// These identifiers and their order are used in the generated code in ReadAndAnalyze for comparisions (== but also &lt;, &gt;=, &gt;=, &gt;)
   /// </summary>
   public enum LexerResult {
      [Description("AddOp(char c)")]
      AddOp = 1,
      [Description("SubOp(char c)")]
      SubOp = 2,
      [Description("MultOp(char c)")]
      MultOp = 4,
      [Description("DivOp(char c)")]
      DivOp = 8,
      [Description("PowOp(char c)")]
      PowOp = 16,
      [Description("OtherCharacter(char c)")]
      OtherCharacter = 32,
      [Description("RightParentheses()")]
      RightParentheses = 64,
      [Description("EndOfLine()")]
      EndOfLine = 128,
      [Description("EqualChar()")]
      EqualChar = 256,
      [Description("LeftParentheses()")]
      LeftParentheses = 512,
      // These symbols are computed by MySymbolInput.cs:
      [Description("Number(double value)")]
      Number = 1024,
      [Description("Identifier(string identifier)")]
      Identifier = 2048
   }

   public static class LexerResultExtensions {
      /// <summary>
      /// Convert the enum value to a one character string if appropriate else to the name of the value
      /// </summary>
      /// <param name="r">The enum value</param>
      /// <returns>The string to display the enum value</returns>
      public static string LexerResultToString(this LexerResult r)
      {
         // Assign a character to each value of LexerResult or assign 'x'
         const string MyDisplay = "+-*/^x)x=(xx";
         char result = MyDisplay[(int)r];

         if (result != 'x')
            return result.ToString();
         else
            return r.ToString(); // "OtherCharacter", "Number", "Identifier"
      }
   }

   public class MyLexer : GrammlatorInputApplication<LexerResult> {
      /// <summary>
      /// The MyCharacterInputClass provides the input for MySymbolInputClass
      /// </summary>
      private readonly MyInputClassifier InputClassifier;
      private int IndexOf1stCharacter = 0;

      // Constructor
      /// <summary>
      /// Constructor of MyLexer
      /// </summary>
      /// <param name="attributeStack">grammlator uses the attributeStack a) in grammlator generated code 
      /// b) to return the attributes of output symbol (if any) and c) to get the attribute of input symbols
      /// </param>
      /// <param name="stateStack">the code generated by grammlator may need a state stack, which can be shared. 
      /// </param>
      /// <param name="inputClassifier"></param>
      /// <param name="externalErrorHandler"></param>
      public MyLexer(
         string line,
          StackOfMultiTypeElements attributeStack,
          Stack<Int32> stateStack
          )
          : base(attributeStack, stateStack)
      {
         InputClassifier = new MyInputClassifier(line, attributeStack: _a);
      }

      // The GetRemainigCharactersOfLine method is specific to this example

      /// <summary>
      /// This method positions the input behind the end of the actual input line and returns the string of skipped characters.
      /// </summary>
      /// <returns>The string of skipped characters (without EndOfLine). Maybe the empty string.</returns>
      public string GetAndSkipRemainingCharactersOfLine()
      {
         return InputClassifier.GetAndSkipRemainigCharactersOfLine(
            Accepted ? InputClassifier.Column : IndexOf1stCharacter
            );
      }

      /* The lexers grammar ist designed such that no lexer error can occur, no error handler is needed  */
      #region grammar
      //| /* This is the first line of Lexer interpreted by the grammlator System. It is interpreted as comment.
      //|    All lines, which contain grammar rules start with //|. They appear as comment to the C# compiler.
      //|    The first line of the grammar lists the prefixes to be used for comparision of symbols
      //|    in the generated code (for example in MyCharacterInput.Symbol == eCharGroup.letter),
      //|    followed by a list of all terminal symbols in correct order as given by the enum declaration in cMyCharacterInput.
      //|    There in addition the attributes of each terminal symbol must be specified exactly as provided by MyCharacterInput.
      //| */
      //|
      //| // Compiler settings
      //| TerminalSymbolEnum: "ClassifierResult"
      //| SymbolNameOrFunctionCall: "Symbol"
      //| SymbolAssignInstruction: "Symbol = InputClassifier.PeekSymbol();"
      //| SymbolAcceptInstruction: "InputClassifier.AcceptSymbol();"
      //| ErrorHandlerMethod: "ErrorHandler"
      //| IfToSwitchBorder: "3";
      //| IsMethod: "_is";
      //|
      //| // Definition of the terminal input symbols of the lexer
      //|      AddOp(char c) | SubOp(char c) | MultOp(char c) | DivOp(char c)
      //|    | PowOp(char c) | OtherCharacter(char c)
      //|    | RightParentheses | EndOfLine | EqualChar | LeftParentheses
      //|    | DecimalPoint  
      //|    | Digit(char c) %50 | Letter(char c) %40

      /* The C# enum at this place is optional. If present it must conicide with the terminal definitions above. */
      public enum CopyOfClassifierResult {
         AddOp = 1, SubOp = 2, MultOp = 4, DivOp = 8, PowOp = 16, OtherCharacter = 32, // all with attribute (char c) 
         RightParentheses = 64, EndOfLine = 128, EqualChar = 256, LeftParentheses = 512,

         DecimalPoint = 1024,
         Digit = 2048, Letter = 4096 // both with attribute (char c)
      };

      //|    /* The attributes of the terminal symbols are defined by a type identifier and an attribute identifier.
      //|       The attribute type must be exactly as given by MyCharacterInput. The identifier has only documentary purposes.
      //|
      //|       The following first grammar rule defines the Startsymbol, which is identified by * and can not be used as a nonterminal symbol.
      //|       When a definition of the startsymbol is recognized its attributes are considered to be attributes of the symbol which is
      //|       returned as result of FetchSymbol() defined below.
      //|      */
      //|
      //| *=   // C# definition of the symbols which MySymbolInput may recognize. The C# code in the following lines can also be placed outside of the grammar.
      //|       Number(double value) 
      private void AssignNumberToSymbol()
      {
         Symbol = LexerResult.Number; // value will be assigned by grammlator generated code
      }

      //|            // the priority <0 ensures that not only the first of a sequence of letters and digits is interpreted as number
      //|       | Identifier(string identifier)  ??-1?? // Make identifier greedy
      private void AssignIdentifierToSymbol()
      {
         Symbol = LexerResult.Identifier; // identifier will be assigned by grammlator generated code
      }

      //|       | SymbolWithAttributeToPassOn(char c)
      private void SymbolWithAttributeToPassOn()
      {
         /* This is a short but not trivial solution to pass input symbols as result to the calling method.
          * Precondition is the consistent definition of the enumerations LexerResult and CharGroupEnum
          * and the knowledge, that there has been no look ahead */
         Symbol = (LexerResult)(InputClassifier.Symbol);
      }

      //|       | SymbolToPassOn
      private void SymbolToPassOn()
      {
         /* This is a short but not trivial solution to pass input symbols as result to the calling method.
          * Precondition is the consistent definition of the enumerations LexerResult and CharGroupEnum
          * and the knowledge, that there has been no look ahead */
         Symbol = (LexerResult)(InputClassifier.Symbol);
      }


      //| SymbolWithAttributeToPassOn(char c)=
      //|         AddOp(char c)
      //|       | SubOp (char c)
      //|       | MultOp(char c)
      //|       | DivOp(char c)
      //|       | PowOp(char c)
      //|       | OtherCharacter(char c);
      //|
      //| SymbolToPassOn=
      //|       | RightParentheses
      //|       | EndOfLine
      //|       | EqualChar 
      //|       | LeftParentheses
      //|       | DecimalPoint;
      //|
      //| integer(double value, int length)= 
      //|    Digit(char c)
      private static void FirstdigitOfNumberRecognized(out double value, out int length, char c)
      {
         value = (int)c - (int)'0';
         length = 1;
      }

      //|    | integer(double value, int length), Digit(char nextDigit) 
      private static void IntegerFollowedByDigitRecognized(ref double value, ref int length, char nextDigit)
      {
         value = (value * 10) + ((int)nextDigit - (int)'0');
         length++;
      }

      //| Number(double value)=
      //|       integer(double value, int notUsed)??-10??
      //|     | integer(double value, int notUsed), DecimalPoint ??-10?? // allow number ending with decimal point
      //|     | integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits)??-11??
      private static void NumberWithDigitsRecognized(ref double value, double valueOfDigits, int numberOfDigits)
      {
         value += (valueOfDigits / System.Math.Pow(10, numberOfDigits));
      }

      //| Identifier(string identifier)=
      //|       Letter(char c)
      private static void FirstCharOfIdentifierRecognized(out string identifier, char c)
      {
         identifier = c.ToString();
      }
      //|     | Identifier(string identifier), letterOrDigit(char c)
      private static void OneMoreCharacterOfIdentifierRecognized(ref string identifier, char c)
      {
         identifier += c.ToString();
      }

      //| letterOrDigit(char c)=  // special case of overlapping attributes. No method needed.
      //|       Letter(char c)
      //|     | Digit(char c )

      #endregion grammar

      // The following few lines up to "#region grammlator generated ..." 
      // and the lines after #endregion are programmed manually
      // The code inside the region "grammlator generated" has been added (or replaced) by gramlator

      public override LexerResult PeekSymbol()
      {
         if (!Accepted)
            return (LexerResult)this.Symbol;
         Accepted = false;
         IndexOf1stCharacter = InputClassifier.Column;
         // Variables which the programmer has to provide for the code generated by grammlator:
         ClassifierResult Symbol;

         /**********************************/
         #region grammlator generated 5 Okt 2020 (grammlator file version/date 2020.10.05.0/5 Okt 2020)
         const ClassifierResult _fRightParentheses = ClassifierResult.RightParentheses;
         const ClassifierResult _fEndOfLine = ClassifierResult.EndOfLine;
         const ClassifierResult _fEqualChar = ClassifierResult.EqualChar;
         const ClassifierResult _fLeftParentheses = ClassifierResult.LeftParentheses;
         const ClassifierResult _fDecimalPoint = ClassifierResult.DecimalPoint;
         const ClassifierResult _fDigit = ClassifierResult.Digit;
         Boolean _is(ClassifierResult flags) => ((Symbol) & flags) != 0;

         // State1:
         /* *Startsymbol= ►Number(double value);
          * *Startsymbol= ►Identifier(string identifier);
          * *Startsymbol= ►SymbolWithAttributeToPassOn(char c);
          * *Startsymbol= ►SymbolToPassOn; */
         Symbol = InputClassifier.PeekSymbol();
         if (Symbol <= ClassifierResult.OtherCharacter)
         {
            InputClassifier.AcceptSymbol();
            // Reduce1:
            /* *Startsymbol= SymbolWithAttributeToPassOn(char c);◄ */

            SymbolWithAttributeToPassOn();

            goto ApplyStartsymbolDefinition2;
         }
         if (Symbol == ClassifierResult.Digit)
         {
            InputClassifier.AcceptSymbol();
            // Reduce3:
            /* aAdjust: 1
             * integer(double value, int length)= Digit(char c);◄ */
            _a.Allocate();

            FirstdigitOfNumberRecognized(
               value: out _a.PeekRef(-1)._double,
               length: out _a.PeekRef(0)._int,
               c: _a.PeekClear(-1)._char
               );

            goto State2;
         }
         if (Symbol >= ClassifierResult.Letter)
         {
            InputClassifier.AcceptSymbol();
            // Reduce4:
            /* Identifier(string identifier)= Letter(char c);◄ */

            FirstCharOfIdentifierRecognized(
               identifier: out _a.PeekRef(0)._string,
               c: _a.PeekClear(0)._char
               );

            goto State5;
         }
         Debug.Assert(_is(_fRightParentheses | _fEndOfLine | _fEqualChar | _fLeftParentheses | _fDecimalPoint));
         InputClassifier.AcceptSymbol();
         // Reduce2:
         /* *Startsymbol= SymbolToPassOn;◄ */

         SymbolToPassOn();

         goto EndOfGeneratedCode;

      Reduce5:
         /* *Startsymbol= Number(double value);◄ */

         AssignNumberToSymbol();

      ApplyStartsymbolDefinition2:
         // Halt: a definition of the startsymbol with 1 attributes has been recognized.
         AttributesOfSymbol.CopyAndRemoveFrom(_a, 1);
         goto EndOfGeneratedCode;

      State2:
         /* Number(double value)= integer(double value, int notUsed)●;
          * Number(double value)= integer(double value, int notUsed), ►DecimalPoint;
          * Number(double value)= integer(double value, int notUsed), ►DecimalPoint, integer(double valueOfDigits, int numberOfDigits);
          * integer(double value, int length)= integer(double value, int length), ►Digit(char nextDigit); */
         Symbol = InputClassifier.PeekSymbol();
         if (Symbol == ClassifierResult.Digit)
         {
            InputClassifier.AcceptSymbol();
            // Reduce7:
            /* aAdjust: -1
             * integer(double value, int length)= integer(double value, int length), Digit(char nextDigit);◄ */

            IntegerFollowedByDigitRecognized(
               value: ref _a.PeekRef(-2)._double,
               length: ref _a.PeekRef(-1)._int,
               nextDigit: _a.PeekRef(0)._char
               );

            _a.Remove();
            goto State2;
         }
         if (Symbol == ClassifierResult.DecimalPoint)
         {
            InputClassifier.AcceptSymbol();
            // State3:
            /* Number(double value)= integer(double value, int notUsed), DecimalPoint●;
             * Number(double value)= integer(double value, int notUsed), DecimalPoint, ►integer(double valueOfDigits, int numberOfDigits); */
            Symbol = InputClassifier.PeekSymbol();
            if (Symbol != ClassifierResult.Digit)
               goto Reduce6;
            Debug.Assert(Symbol == ClassifierResult.Digit);
            InputClassifier.AcceptSymbol();
            // Reduce8:
            /* aAdjust: 1
             * integer(double value, int length)= Digit(char c);◄ */
            _a.Allocate();

            FirstdigitOfNumberRecognized(
               value: out _a.PeekRef(-1)._double,
               length: out _a.PeekRef(0)._int,
               c: _a.PeekClear(-1)._char
               );

            goto State4;
         }
         Debug.Assert(!_is(_fDecimalPoint | _fDigit));
      Reduce6:
         /* aAdjust: -1
          * Number(double value)= integer(double value, int notUsed);◄
          * or: Number(double value)= integer(double value, int notUsed), DecimalPoint;◄ */
         _a.Remove();
         goto Reduce5;

      State4:
         /* Number(double value)= integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits)●;
          * integer(double value, int length)= integer(double value, int length), ►Digit(char nextDigit); */
         Symbol = InputClassifier.PeekSymbol();
         if (Symbol != ClassifierResult.Digit)
         // Reduce9:
         {
            /* aAdjust: -3
             * Number(double value)= integer(double value, int notUsed), DecimalPoint, integer(double valueOfDigits, int numberOfDigits);◄ */

            NumberWithDigitsRecognized(
               value: ref _a.PeekRef(-3)._double,
               valueOfDigits: _a.PeekRef(-1)._double,
               numberOfDigits: _a.PeekRef(0)._int
               );

            _a.Remove(3);
            goto Reduce5;
         }
         Debug.Assert(Symbol == ClassifierResult.Digit);
         InputClassifier.AcceptSymbol();
         // Reduce10:
         /* aAdjust: -1
          * integer(double value, int length)= integer(double value, int length), Digit(char nextDigit);◄ */

         IntegerFollowedByDigitRecognized(
            value: ref _a.PeekRef(-2)._double,
            length: ref _a.PeekRef(-1)._int,
            nextDigit: _a.PeekRef(0)._char
            );

         _a.Remove();
         goto State4;

      State5:
         /* *Startsymbol= Identifier(string identifier)●;
          * Identifier(string identifier)= Identifier(string identifier), ►letterOrDigit(char c); */
         Symbol = InputClassifier.PeekSymbol();
         if (Symbol <= ClassifierResult.DecimalPoint)
         // Reduce11:
         {
            /* *Startsymbol= Identifier(string identifier);◄ */

            AssignIdentifierToSymbol();

            goto ApplyStartsymbolDefinition2;
         }
         Debug.Assert(Symbol >= ClassifierResult.Digit);
         InputClassifier.AcceptSymbol();
         // Reduce12:
         /* aAdjust: -1
          * Identifier(string identifier)= Identifier(string identifier), letterOrDigit(char c);◄ */

         OneMoreCharacterOfIdentifierRecognized(
            identifier: ref _a.PeekRef(-1)._string,
            c: _a.PeekRef(0)._char
            );

         _a.Remove();
         goto State5;

      EndOfGeneratedCode:
         ;

         #endregion grammlator generated 5 Okt 2020 (grammlator file version/date 2020.10.05.0/5 Okt 2020)
#pragma warning restore IDE0059 // Der Wert, der dem Symbol zugeordnet ist, wird niemals verwendet.

         return (LexerResult)(this.Symbol);
      }
   }
}
